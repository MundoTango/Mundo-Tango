/**
 * AI INTELLIGENCE INFRASTRUCTURE - COMPREHENSIVE TEST SUITE
 * 
 * This test suite validates the complete AI Intelligence Infrastructure including:
 * 1. Learning Index API (7 endpoints) - Pattern search, agent specs, validation
 * 2. Agent Communication API (18 endpoints) - A2A messaging, escalation, collaboration
 * 3. Knowledge Graph API (17 endpoints) - Semantic search, relationships, expertise
 * 4. Pattern Recognition Engine (23 endpoints) - Learning, validation, distribution
 * 5. Multi-AI Orchestration (13 endpoints) - Smart routing, fallback chains, cost optimization
 * 
 * Total Coverage: 78+ API endpoints
 * 
 * Test Categories:
 * - Happy path (200 responses with valid data)
 * - Data validation (correct schemas and types)
 * - Error handling (400, 404, 500 responses)
 * - Authentication/Authorization (role-based access)
 * - Integration (cross-service communication)
 * - Database operations (create, read, update)
 */

import { test, expect } from '@playwright/test';

// ============================================================================
// TEST UTILITIES & HELPERS
// ============================================================================

/**
 * Mock authentication token for testing
 * In production, this would be generated by the auth system
 */
const mockAuthToken = 'test_admin_token';
const mockUserToken = 'test_user_token';

/**
 * Common headers for authenticated requests
 */
const authHeaders = {
  'Authorization': `Bearer ${mockAuthToken}`,
  'Content-Type': 'application/json',
};

const userAuthHeaders = {
  'Authorization': `Bearer ${mockUserToken}`,
  'Content-Type': 'application/json',
};

// ============================================================================
// 1. LEARNING INDEX API TESTS (7 endpoints)
// ============================================================================

test.describe('Learning Index API - Pattern Search & Agent Specs', () => {
  
  test('GET /api/learning/search - should search patterns by keyword', async ({ request }) => {
    const response = await request.get('/api/learning/search?keyword=authentication&limit=10&offset=0&searchIn=patterns');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data).toHaveProperty('query');
    expect(data).toHaveProperty('searchIn');
    expect(data).toHaveProperty('totalResults');
    expect(data).toHaveProperty('results');
    expect(data).toHaveProperty('metadata');
    
    if (data.totalResults > 0) {
      expect(Array.isArray(data.results)).toBe(true);
      expect(data.results[0]).toHaveProperty('name');
    }
  });

  test('GET /api/learning/search - should search all content', async ({ request }) => {
    const response = await request.get('/api/learning/search?keyword=API&limit=20&searchIn=all');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data.searchIn).toBe('all');
    expect(data.results).toBeDefined();
    expect(data.metadata.limit).toBe(20);
  });

  test('GET /api/learning/search - should search for agents', async ({ request }) => {
    const response = await request.get('/api/learning/search?keyword=Agent&searchIn=agents');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data.searchIn).toBe('agents');
    if (data.totalResults > 0) {
      expect(data.results[0]).toHaveProperty('id');
      expect(data.results[0]).toHaveProperty('context');
    }
  });

  test('GET /api/learning/search - should handle missing keyword (400)', async ({ request }) => {
    const response = await request.get('/api/learning/search?limit=10');
    
    expect(response.status()).toBe(400);
    const data = await response.json();
    expect(data).toHaveProperty('error');
  });

  test('GET /api/learning/agents/:agentId - should get agent specifications', async ({ request }) => {
    const response = await request.get('/api/learning/agents/A1');
    
    // Should return 200 if agent exists, or 404 if not found
    expect([200, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('agentId');
      expect(data).toHaveProperty('specification');
    }
  });

  test('GET /api/learning/agents/:agentId - should support multiple agent ID formats', async ({ request }) => {
    // Test different formats: A1, 79, #79
    const agentIds = ['A1', '79', '#79'];
    
    for (const agentId of agentIds) {
      const response = await request.get(`/api/learning/agents/${agentId}`);
      expect([200, 404]).toContain(response.status());
    }
  });

  test('GET /api/learning/patterns/:patternId - should get specific pattern', async ({ request }) => {
    const response = await request.get('/api/learning/patterns/1');
    
    expect([200, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('patternId');
      expect(data).toHaveProperty('content');
    }
  });

  test('GET /api/learning/appendix/:appendixId - should get appendix section', async ({ request }) => {
    const response = await request.get('/api/learning/appendix/A');
    
    expect([200, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('appendixId');
      expect(data).toHaveProperty('content');
    }
  });

  test('GET /api/learning/stats - should return learning index statistics', async ({ request }) => {
    const response = await request.get('/api/learning/stats');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data).toHaveProperty('totalPatterns');
    expect(data).toHaveProperty('totalAgents');
    expect(data).toHaveProperty('totalAppendices');
    expect(data).toHaveProperty('fileSize');
    expect(typeof data.totalPatterns).toBe('number');
  });

  test('POST /api/learning/validate - should validate guardrails', async ({ request }) => {
    const response = await request.post('/api/learning/validate', {
      data: {
        content: 'Test authentication implementation',
        checkAgainst: ['security', 'best-practices']
      }
    });
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data).toHaveProperty('valid');
    expect(data).toHaveProperty('violations');
    expect(data).toHaveProperty('suggestions');
    expect(Array.isArray(data.violations)).toBe(true);
  });

  test('GET /api/learning/health - should return health status', async ({ request }) => {
    const response = await request.get('/api/learning/health');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    
    expect(data).toHaveProperty('status');
    expect(data).toHaveProperty('indexAvailable');
    expect(data.status).toBe('healthy');
  });
});

// ============================================================================
// 2. AGENT COMMUNICATION API TESTS (18 endpoints)
// ============================================================================

test.describe('Agent Communication API - A2A Messaging & Collaboration', () => {
  
  test('POST /api/agent-communication/send - should send message between agents', async ({ request }) => {
    const response = await request.post('/api/agent-communication/send', {
      headers: authHeaders,
      data: {
        fromAgentId: 'A1',
        toAgentIds: ['A2', 'A3'],
        messageType: 'command',
        subject: 'Test Message',
        message: 'This is a test message',
        priority: 'normal',
        requiresResponse: false
      }
    });
    
    expect([200, 401, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.messagesSent).toBeGreaterThan(0);
      expect(Array.isArray(data.communications)).toBe(true);
    }
  });

  test('POST /api/agent-communication/send - should require authentication', async ({ request }) => {
    const response = await request.post('/api/agent-communication/send', {
      data: {
        fromAgentId: 'A1',
        toAgentIds: ['A2'],
        messageType: 'query',
        subject: 'Test',
        message: 'Test'
      }
    });
    
    expect(response.status()).toBe(401);
  });

  test('POST /api/agent-communication/send - should validate message types', async ({ request }) => {
    const response = await request.post('/api/agent-communication/send', {
      headers: authHeaders,
      data: {
        fromAgentId: 'A1',
        toAgentIds: ['A2'],
        messageType: 'invalid_type', // Invalid type
        subject: 'Test',
        message: 'Test'
      }
    });
    
    expect(response.status()).toBe(400);
    const data = await response.json();
    expect(data).toHaveProperty('error');
  });

  test('GET /api/agent-communication/messages/:agentId - should get agent inbox', async ({ request }) => {
    const response = await request.get('/api/agent-communication/messages/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('messages');
      expect(data).toHaveProperty('total');
      expect(Array.isArray(data.messages)).toBe(true);
    }
  });

  test('GET /api/agent-communication/messages/:agentId - should support filtering', async ({ request }) => {
    const response = await request.get('/api/agent-communication/messages/A1?type=command&priority=high&unrespondedOnly=true', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('GET /api/agent-communication/messages/:agentId/sent - should get sent messages', async ({ request }) => {
    const response = await request.get('/api/agent-communication/messages/A1/sent', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-communication/escalate - should escalate issue', async ({ request }) => {
    const response = await request.post('/api/agent-communication/escalate', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        issue: 'Critical authentication failure',
        attemptedSolutions: ['Checked credentials', 'Reviewed logs'],
        blockingIssue: 'Cannot authenticate users',
        helpNeeded: 'Need security expert assistance',
        impact: 'Users cannot login',
        suggestedAgents: ['A5']
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data).toHaveProperty('escalationId');
      expect(data).toHaveProperty('assignedTo');
    }
  });

  test('GET /api/agent-communication/escalations - should get all escalations', async ({ request }) => {
    const response = await request.get('/api/agent-communication/escalations', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.escalations)).toBe(true);
      expect(data).toHaveProperty('total');
    }
  });

  test('POST /api/agent-communication/collaborate - should request collaboration', async ({ request }) => {
    const response = await request.post('/api/agent-communication/collaborate', {
      headers: authHeaders,
      data: {
        requestingAgent: 'A1',
        issue: 'Complex database optimization needed',
        expertiseNeeded: ['database', 'performance'],
        impact: 'Slow query performance affecting users',
        urgency: 'high'
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data).toHaveProperty('collaborationId');
      expect(data).toHaveProperty('suggestedExperts');
    }
  });

  test('GET /api/agent-communication/collaborations - should get collaborations', async ({ request }) => {
    const response = await request.get('/api/agent-communication/collaborations', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('PATCH /api/agent-communication/resolve/:id - should resolve escalation', async ({ request }) => {
    const response = await request.patch('/api/agent-communication/resolve/1', {
      headers: authHeaders,
      data: {
        resolution: 'Issue resolved by implementing new auth flow',
        outcome: 'success'
      }
    });
    
    expect([200, 400, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-communication/respond/:id - should respond to message', async ({ request }) => {
    const response = await request.post('/api/agent-communication/respond/1', {
      headers: authHeaders,
      data: {
        responseMessage: 'Message acknowledged and processing'
      }
    });
    
    expect([200, 400, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-communication/emergency - should declare emergency', async ({ request }) => {
    const response = await request.post('/api/agent-communication/emergency', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        situation: 'Critical database failure',
        impact: 'All user data access is down',
        affectedSystems: ['database', 'api', 'frontend'],
        immediateActions: ['Failover to backup', 'Alert on-call team']
      }
    });
    
    expect([200, 400, 401, 403]).toContain(response.status());
  });

  test('GET /api/agent-communication/broadcast-history - should get broadcast history', async ({ request }) => {
    const response = await request.get('/api/agent-communication/broadcast-history', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('GET /api/agent-communication/stats - should get communication stats', async ({ request }) => {
    const response = await request.get('/api/agent-communication/stats', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('totalMessages');
      expect(data).toHaveProperty('escalations');
      expect(data).toHaveProperty('collaborations');
    }
  });

  test('GET /api/agent-communication/conversation/:id - should get conversation thread', async ({ request }) => {
    const response = await request.get('/api/agent-communication/conversation/1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-communication/broadcast - should broadcast change', async ({ request }) => {
    const response = await request.post('/api/agent-communication/broadcast', {
      headers: authHeaders,
      data: {
        changeType: 'code_update',
        changeDescription: 'Updated authentication flow',
        initiatedBy: 'A1',
        priority: 'high'
      }
    });
    
    expect([200, 400, 401, 403]).toContain(response.status());
  });

  test('GET /api/agent-communication/broadcasts/:id - should get broadcast details', async ({ request }) => {
    const response = await request.get('/api/agent-communication/broadcasts/1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-communication/broadcasts/:id/acknowledge - should acknowledge broadcast', async ({ request }) => {
    const response = await request.post('/api/agent-communication/broadcasts/1/acknowledge', {
      headers: authHeaders,
      data: {
        agentId: 'A2',
        processingTime: 150
      }
    });
    
    expect([200, 400, 401, 404]).toContain(response.status());
  });

  test('GET /api/agent-communication/hierarchy/:agentId - should get agent hierarchy', async ({ request }) => {
    const response = await request.get('/api/agent-communication/hierarchy/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('GET /api/agent-communication/workload - should get workload distribution', async ({ request }) => {
    const response = await request.get('/api/agent-communication/workload', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });
});

// ============================================================================
// 3. KNOWLEDGE GRAPH API TESTS (17 endpoints)
// ============================================================================

test.describe('Knowledge Graph API - Semantic Search & Relationships', () => {
  
  test('POST /api/knowledge/search - should search knowledge semantically', async ({ request }) => {
    const response = await request.post('/api/knowledge/search', {
      headers: authHeaders,
      data: {
        query: 'authentication best practices',
        limit: 10,
        filters: {
          category: 'bug_fix',
          minConfidence: 0.7
        }
      }
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('query');
      expect(data).toHaveProperty('results');
      expect(data).toHaveProperty('totalResults');
      expect(Array.isArray(data.results)).toBe(true);
    }
  });

  test('GET /api/knowledge/graph/:agentId - should get agent knowledge graph', async ({ request }) => {
    const response = await request.get('/api/knowledge/graph/A1?depth=2', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('node');
      expect(data).toHaveProperty('relationships');
      expect(data).toHaveProperty('depth');
    }
  });

  test('POST /api/knowledge/pattern - should create knowledge pattern', async ({ request }) => {
    const response = await request.post('/api/knowledge/pattern', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        patternName: 'Authentication Error Fix',
        category: 'bug_fix',
        domain: 'security',
        problemSignature: 'JWT token validation fails',
        solutionTemplate: 'Update token verification logic',
        confidence: 0.9,
        tags: ['auth', 'jwt', 'security']
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('id');
      expect(data).toHaveProperty('patternName');
    }
  });

  test('GET /api/knowledge/patterns - should list all patterns', async ({ request }) => {
    const response = await request.get('/api/knowledge/patterns?limit=20&offset=0', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.patterns)).toBe(true);
      expect(data).toHaveProperty('total');
    }
  });

  test('GET /api/knowledge/patterns/:id - should get specific pattern', async ({ request }) => {
    const response = await request.get('/api/knowledge/patterns/1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/knowledge/expertise - should find experts', async ({ request }) => {
    const response = await request.post('/api/knowledge/expertise', {
      headers: authHeaders,
      data: {
        requiredCapabilities: ['database', 'optimization'],
        preferredExpertise: ['postgresql'],
        taskType: 'query optimization',
        urgency: 'high',
        limit: 5
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.experts)).toBe(true);
      expect(data).toHaveProperty('matchCriteria');
    }
  });

  test('GET /api/knowledge/expertise/:domain - should get domain experts', async ({ request }) => {
    const response = await request.get('/api/knowledge/expertise/security', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('POST /api/knowledge/relationships - should create relationship', async ({ request }) => {
    const response = await request.post('/api/knowledge/relationships', {
      headers: authHeaders,
      data: {
        sourceAgentCode: 'A1',
        targetAgentCode: 'A2',
        relationshipType: 'collaborates_with',
        strength: 0.8
      }
    });
    
    expect([200, 400, 401, 403]).toContain(response.status());
  });

  test('GET /api/knowledge/network-analysis - should analyze knowledge network', async ({ request }) => {
    const response = await request.get('/api/knowledge/network-analysis', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('GET /api/knowledge/domains - should list all domains', async ({ request }) => {
    const response = await request.get('/api/knowledge/domains', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.domains)).toBe(true);
    }
  });

  test('GET /api/knowledge/stats - should get knowledge stats', async ({ request }) => {
    const response = await request.get('/api/knowledge/stats', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('totalPatterns');
      expect(data).toHaveProperty('totalAgents');
      expect(data).toHaveProperty('totalRelationships');
    }
  });

  test('GET /api/knowledge/statistics - should get detailed statistics', async ({ request }) => {
    const response = await request.get('/api/knowledge/statistics', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('PATCH /api/knowledge/patterns/:id - should update pattern', async ({ request }) => {
    const response = await request.patch('/api/knowledge/patterns/1', {
      headers: authHeaders,
      data: {
        confidence: 0.95,
        tags: ['updated', 'validated']
      }
    });
    
    expect([200, 400, 401, 404]).toContain(response.status());
  });

  test('GET /api/knowledge/graph/agents - should get all agents in graph', async ({ request }) => {
    const response = await request.get('/api/knowledge/graph/agents', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('GET /api/knowledge/graph/relationships/:agentId - should get agent relationships', async ({ request }) => {
    const response = await request.get('/api/knowledge/graph/relationships/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/knowledge/flow - should track knowledge flow', async ({ request }) => {
    const response = await request.post('/api/knowledge/flow', {
      headers: authHeaders,
      data: {
        fromAgent: 'A1',
        toAgent: 'A2',
        knowledgeType: 'pattern',
        knowledgeId: 1
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
  });

  test('GET /api/knowledge/gaps - should identify knowledge gaps', async ({ request }) => {
    const response = await request.get('/api/knowledge/gaps', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.gaps)).toBe(true);
    }
  });
});

// ============================================================================
// 4. PATTERN RECOGNITION / AGENT INTELLIGENCE TESTS (23 endpoints)
// ============================================================================

test.describe('Pattern Recognition & Agent Intelligence Engine', () => {
  
  test('GET /api/agent-intelligence/agents - should list all agents', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/agents?limit=20', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.agents)).toBe(true);
      expect(data).toHaveProperty('total');
    }
  });

  test('GET /api/agent-intelligence/agents/:agentCode - should get agent details', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/agents/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('agent');
      expect(data).toHaveProperty('recentTasks');
    }
  });

  test('POST /api/agent-intelligence/validate - should validate feature', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/validate', {
      headers: authHeaders,
      data: {
        feature: 'User Authentication',
        page: 'LoginPage',
        targetAgent: 'A1',
        testType: 'functional'
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('validationId');
      expect(data).toHaveProperty('status');
    }
  });

  test('GET /api/agent-intelligence/validations/:agentId - should get validation history', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/validations/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-intelligence/learn - should capture learning', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/learn', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        category: 'bug_fix',
        domain: 'authentication',
        problem: 'JWT token expiration not handled',
        solution: 'Implemented token refresh logic',
        outcome: {
          success: true,
          impact: 'high',
          timeSaved: '2 hours'
        },
        confidence: 0.9
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('patternId');
      expect(data).toHaveProperty('distributed');
    }
  });

  test('GET /api/agent-intelligence/patterns - should list patterns', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/patterns?category=bug_fix&limit=15', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.patterns)).toBe(true);
    }
  });

  test('POST /api/agent-intelligence/patterns/search - should search patterns', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/patterns/search', {
      headers: authHeaders,
      data: {
        query: 'database optimization',
        category: 'optimization',
        limit: 10,
        minConfidence: 0.7
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.results)).toBe(true);
      expect(data).toHaveProperty('totalResults');
    }
  });

  test('POST /api/agent-intelligence/find-solution - should find solution for problem', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/find-solution', {
      headers: authHeaders,
      data: {
        category: 'bug_fix',
        domain: 'database',
        problem: 'Slow query performance on user table',
        severity: 'high'
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('solutions');
      expect(Array.isArray(data.solutions)).toBe(true);
    }
  });

  test('GET /api/agent-intelligence/patterns/:id - should get pattern by ID', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/patterns/1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
  });

  test('POST /api/agent-intelligence/distribute-knowledge - should distribute knowledge', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/distribute-knowledge', {
      headers: authHeaders,
      data: {
        patternId: 1,
        priority: 'high'
      }
    });
    
    expect([200, 400, 401, 403]).toContain(response.status());
  });

  test('GET /api/agent-intelligence/stats - should get intelligence stats', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/stats', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('totalAgents');
      expect(data).toHaveProperty('totalPatterns');
      expect(data).toHaveProperty('totalValidations');
    }
  });

  test('GET /api/agent-intelligence/learning-cycles - should get learning cycles', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/learning-cycles', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
  });

  test('POST /api/agent-intelligence/synthesize-patterns - should synthesize patterns', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/synthesize-patterns', {
      headers: authHeaders,
      data: {
        domain: 'authentication',
        minPatterns: 3
      }
    });
    
    expect([200, 400, 401, 403]).toContain(response.status());
  });

  test('GET /api/agent-intelligence/top-performers - should get top performing agents', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/top-performers?limit=10', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.topPerformers)).toBe(true);
    }
  });

  test('PATCH /api/agent-intelligence/agents/:agentCode/certify - should certify agent', async ({ request }) => {
    const response = await request.patch('/api/agent-intelligence/agents/A1/certify', {
      headers: authHeaders,
      data: {
        certificationLevel: 2,
        certifiedBy: 'A0'
      }
    });
    
    expect([200, 400, 401, 403, 404]).toContain(response.status());
  });

  test('POST /api/agent-intelligence/collaboration - should request collaboration', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/collaboration', {
      headers: authHeaders,
      data: {
        requestingAgent: 'A1',
        requiredExpertise: ['database'],
        task: 'Optimize query performance',
        urgency: 'high'
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
  });

  test('GET /api/agent-intelligence/performance/:agentId - should get agent performance', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/performance/A1', {
      headers: authHeaders,
    });
    
    expect([200, 401, 404]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('metrics');
    }
  });

  test('GET /api/agent-intelligence/alerts - should get performance alerts', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/alerts', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(Array.isArray(data.alerts)).toBe(true);
    }
  });

  test('POST /api/agent-intelligence/alerts/:id/acknowledge - should acknowledge alert', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/alerts/1/acknowledge', {
      headers: authHeaders,
      data: {
        acknowledgedBy: 'A1',
        notes: 'Alert reviewed and addressed'
      }
    });
    
    expect([200, 400, 401, 404]).toContain(response.status());
  });

  test('GET /api/agent-intelligence/knowledge/search - should search knowledge base', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/knowledge/search?query=authentication', {
      headers: authHeaders,
    });
    
    expect([200, 400, 401]).toContain(response.status());
  });

  test('POST /api/agent-intelligence/distribute - should distribute pattern', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/distribute', {
      headers: authHeaders,
      data: {
        patternId: 1,
        targetAgents: ['A2', 'A3'],
        priority: 'medium'
      }
    });
    
    expect([200, 400, 401]).toContain(response.status());
  });

  test('GET /api/agent-intelligence/metrics - should get system metrics', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/metrics', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data).toHaveProperty('systemHealth');
      expect(data).toHaveProperty('agentMetrics');
    }
  });

  test('GET /api/agent-intelligence/health - should get health status', async ({ request }) => {
    const response = await request.get('/api/agent-intelligence/health');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    expect(data).toHaveProperty('status');
    expect(data.status).toBe('healthy');
  });
});

// ============================================================================
// 5. MULTI-AI ORCHESTRATION TESTS (13 endpoints)
// ============================================================================

test.describe('Multi-AI Orchestration - Smart Routing & Load Balancing', () => {
  
  test('POST /api/ai/chat - should route chat request smartly', async ({ request }) => {
    const response = await request.post('/api/ai/chat', {
      headers: authHeaders,
      data: {
        query: 'Explain async/await in JavaScript',
        priority: 'balanced',
        temperature: 0.7,
        maxTokens: 500
      }
    });
    
    expect([200, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('content');
      expect(data.data).toHaveProperty('metadata');
      expect(data.data.metadata).toHaveProperty('platform');
      expect(data.data.metadata).toHaveProperty('model');
      expect(data.data.metadata).toHaveProperty('cost');
      expect(data.data.metadata).toHaveProperty('latency');
    }
  });

  test('POST /api/ai/chat - should support priority routing', async ({ request }) => {
    const priorities = ['speed', 'cost', 'quality', 'balanced'];
    
    for (const priority of priorities) {
      const response = await request.post('/api/ai/chat', {
        headers: authHeaders,
        data: {
          query: 'Test query',
          priority
        }
      });
      
      expect([200, 401, 500]).toContain(response.status());
    }
  });

  test('POST /api/ai/code - should generate code with quality priority', async ({ request }) => {
    const response = await request.post('/api/ai/code', {
      headers: authHeaders,
      data: {
        query: 'Write a function to validate email addresses',
        priority: 'quality',
        temperature: 0.3,
        maxTokens: 1000
      }
    });
    
    expect([200, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('code');
      expect(data.data.metadata).toHaveProperty('platform');
    }
  });

  test('POST /api/ai/reasoning - should provide deep reasoning', async ({ request }) => {
    const response = await request.post('/api/ai/reasoning', {
      headers: authHeaders,
      data: {
        query: 'Analyze the trade-offs between SQL and NoSQL databases',
        temperature: 0.5,
        maxTokens: 2000
      }
    });
    
    expect([200, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('analysis');
    }
  });

  test('POST /api/ai/bulk - should process bulk queries', async ({ request }) => {
    const response = await request.post('/api/ai/bulk', {
      headers: authHeaders,
      data: {
        queries: [
          'What is React?',
          'What is Vue?',
          'What is Angular?'
        ],
        temperature: 0.7,
        maxTokens: 200
      }
    });
    
    expect([200, 400, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(Array.isArray(data.data.responses)).toBe(true);
      expect(data.data.responses.length).toBe(3);
    }
  });

  test('GET /api/ai/cost-stats - should get cost statistics', async ({ request }) => {
    const response = await request.get('/api/ai/cost-stats', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('totalCost');
      expect(data.data).toHaveProperty('costByPlatform');
    }
  });

  test('GET /api/ai/platform-status - should get platform health', async ({ request }) => {
    const response = await request.get('/api/ai/platform-status', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('platforms');
      expect(Array.isArray(data.data.platforms)).toBe(true);
    }
  });

  test('POST /api/ai/collaborative-analysis - should perform collaborative analysis', async ({ request }) => {
    const response = await request.post('/api/ai/collaborative-analysis', {
      headers: authHeaders,
      data: {
        query: 'Review this authentication code for security issues: const login = async (user, pass) => { return jwt.sign({user}, SECRET) }',
        analysisType: 'security'
      }
    });
    
    expect([200, 400, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('perspectives');
      expect(Array.isArray(data.data.perspectives)).toBe(true);
    }
  });

  test('GET /api/ai/cache-stats - should get cache statistics', async ({ request }) => {
    const response = await request.get('/api/ai/cache-stats', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('hitRate');
      expect(data.data).toHaveProperty('totalRequests');
    }
  });

  test('POST /api/ai/embeddings - should generate embeddings', async ({ request }) => {
    const response = await request.post('/api/ai/embeddings', {
      headers: authHeaders,
      data: {
        text: 'This is a test document for embedding generation'
      }
    });
    
    expect([200, 400, 401, 500]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('embedding');
      expect(Array.isArray(data.data.embedding)).toBe(true);
    }
  });

  test('GET /api/ai/rate-limits - should get rate limit status', async ({ request }) => {
    const response = await request.get('/api/ai/rate-limits', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(data.data).toHaveProperty('limits');
    }
  });

  test('POST /api/ai/cache/clear - should clear AI cache', async ({ request }) => {
    const response = await request.post('/api/ai/cache/clear', {
      headers: authHeaders,
    });
    
    expect([200, 401, 403]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
    }
  });

  test('GET /api/ai/health - should get orchestration health', async ({ request }) => {
    const response = await request.get('/api/ai/health');
    
    expect(response.status()).toBe(200);
    const data = await response.json();
    expect(data.success).toBe(true);
    expect(data).toHaveProperty('status');
  });

  test('GET /api/ai/platforms - should list available platforms', async ({ request }) => {
    const response = await request.get('/api/ai/platforms', {
      headers: authHeaders,
    });
    
    expect([200, 401]).toContain(response.status());
    
    if (response.status() === 200) {
      const data = await response.json();
      expect(data.success).toBe(true);
      expect(Array.isArray(data.data.platforms)).toBe(true);
    }
  });
});

// ============================================================================
// ERROR HANDLING & EDGE CASES
// ============================================================================

test.describe('Error Handling & Edge Cases', () => {
  
  test('should handle malformed JSON gracefully', async ({ request }) => {
    const response = await request.post('/api/agent-intelligence/learn', {
      headers: {
        ...authHeaders,
        'Content-Type': 'application/json',
      },
      data: '{ malformed json }',
      failOnStatusCode: false,
    });
    
    expect([400, 500]).toContain(response.status());
  });

  test('should handle missing required fields', async ({ request }) => {
    const response = await request.post('/api/agent-communication/send', {
      headers: authHeaders,
      data: {
        fromAgentId: 'A1',
        // Missing required fields
      }
    });
    
    expect(response.status()).toBe(400);
  });

  test('should handle invalid enum values', async ({ request }) => {
    const response = await request.post('/api/knowledge/pattern', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        patternName: 'Test',
        category: 'invalid_category', // Invalid
        domain: 'test',
        problemSignature: 'test',
        solutionTemplate: 'test'
      }
    });
    
    expect(response.status()).toBe(400);
  });

  test('should handle very long input strings', async ({ request }) => {
    const longString = 'a'.repeat(50000);
    
    const response = await request.post('/api/knowledge/search', {
      headers: authHeaders,
      data: {
        query: longString,
        limit: 10
      }
    });
    
    expect([200, 400, 413]).toContain(response.status());
  });

  test('should handle concurrent requests properly', async ({ request }) => {
    const requests = Array(10).fill(null).map(() =>
      request.get('/api/agent-intelligence/agents', {
        headers: authHeaders,
      })
    );
    
    const responses = await Promise.all(requests);
    
    // All should succeed or fail consistently
    responses.forEach(response => {
      expect([200, 401, 429]).toContain(response.status());
    });
  });

  test('should return 404 for non-existent endpoints', async ({ request }) => {
    const response = await request.get('/api/non-existent-endpoint');
    
    expect(response.status()).toBe(404);
  });

  test('should validate numeric parameters', async ({ request }) => {
    const response = await request.get('/api/learning/search?keyword=test&limit=invalid', {
      headers: authHeaders,
    });
    
    expect([200, 400]).toContain(response.status());
  });
});

// ============================================================================
// INTEGRATION TESTS - Cross-Service Communication
// ============================================================================

test.describe('Integration Tests - Cross-Service Communication', () => {
  
  test('Learning → Pattern Recognition flow', async ({ request }) => {
    // Step 1: Capture a learning
    const learnResponse = await request.post('/api/agent-intelligence/learn', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        category: 'bug_fix',
        domain: 'database',
        problem: 'N+1 query problem',
        solution: 'Implemented eager loading',
        outcome: {
          success: true,
          impact: 'high',
          timeSaved: '3 hours'
        },
        confidence: 0.95
      }
    });
    
    if (learnResponse.status() === 200) {
      const learnData = await learnResponse.json();
      const patternId = learnData.patternId;
      
      // Step 2: Search for the pattern
      const searchResponse = await request.post('/api/agent-intelligence/patterns/search', {
        headers: authHeaders,
        data: {
          query: 'N+1 query',
          category: 'bug_fix',
          limit: 10
        }
      });
      
      if (searchResponse.status() === 200) {
        const searchData = await searchResponse.json();
        // Pattern should be found
        expect(searchData.totalResults).toBeGreaterThan(0);
      }
    }
  });

  test('Communication → Collaboration flow', async ({ request }) => {
    // Step 1: Request collaboration
    const collaborateResponse = await request.post('/api/agent-communication/collaborate', {
      headers: authHeaders,
      data: {
        requestingAgent: 'A1',
        issue: 'Performance optimization needed',
        expertiseNeeded: ['database', 'caching'],
        impact: 'High latency affecting users',
        urgency: 'high'
      }
    });
    
    if (collaborateResponse.status() === 200) {
      const collaborateData = await collaborateResponse.json();
      
      // Step 2: Get collaboration details
      const listResponse = await request.get('/api/agent-communication/collaborations', {
        headers: authHeaders,
      });
      
      expect([200, 401]).toContain(listResponse.status());
    }
  });

  test('Knowledge Graph → Expert Finding flow', async ({ request }) => {
    // Step 1: Create a pattern
    const patternResponse = await request.post('/api/knowledge/pattern', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        patternName: 'Cache Optimization Pattern',
        category: 'optimization',
        domain: 'caching',
        problemSignature: 'Slow cache lookups',
        solutionTemplate: 'Implement Redis pipelining',
        confidence: 0.9
      }
    });
    
    // Step 2: Find experts in caching
    const expertResponse = await request.post('/api/knowledge/expertise', {
      headers: authHeaders,
      data: {
        requiredCapabilities: ['caching'],
        taskType: 'optimization',
        urgency: 'medium',
        limit: 5
      }
    });
    
    if (expertResponse.status() === 200) {
      const expertData = await expertResponse.json();
      expect(Array.isArray(expertData.experts)).toBe(true);
    }
  });

  test('Multi-AI → Knowledge Distribution flow', async ({ request }) => {
    // Step 1: Generate insights using AI
    const aiResponse = await request.post('/api/ai/reasoning', {
      headers: authHeaders,
      data: {
        query: 'Best practices for database indexing in high-traffic applications',
        temperature: 0.5,
        maxTokens: 1500
      }
    });
    
    if (aiResponse.status() === 200) {
      const aiData = await aiResponse.json();
      
      // Step 2: Capture as learning
      const learnResponse = await request.post('/api/agent-intelligence/learn', {
        headers: authHeaders,
        data: {
          agentId: 'A1',
          category: 'pattern',
          domain: 'database',
          problem: 'Database indexing strategy',
          solution: aiData.data.analysis.substring(0, 500),
          outcome: {
            success: true,
            impact: 'high'
          },
          confidence: 0.8
        }
      });
      
      expect([200, 400, 401]).toContain(learnResponse.status());
    }
  });

  test('Pattern Recognition → Communication flow', async ({ request }) => {
    // Step 1: Find solution for problem
    const solutionResponse = await request.post('/api/agent-intelligence/find-solution', {
      headers: authHeaders,
      data: {
        category: 'bug_fix',
        domain: 'security',
        problem: 'SQL injection vulnerability',
        severity: 'critical'
      }
    });
    
    if (solutionResponse.status() === 200) {
      const solutionData = await solutionResponse.json();
      
      // Step 2: Broadcast the solution
      if (solutionData.solutions && solutionData.solutions.length > 0) {
        const broadcastResponse = await request.post('/api/agent-communication/broadcast', {
          headers: authHeaders,
          data: {
            changeType: 'pattern_learned',
            changeDescription: 'New security pattern discovered',
            initiatedBy: 'A1',
            priority: 'critical'
          }
        });
        
        expect([200, 400, 401, 403]).toContain(broadcastResponse.status());
      }
    }
  });

  test('Complete workflow: Problem → Learn → Distribute → Validate', async ({ request }) => {
    // Step 1: Find solution for a problem
    const findResponse = await request.post('/api/agent-intelligence/find-solution', {
      headers: authHeaders,
      data: {
        category: 'optimization',
        domain: 'frontend',
        problem: 'Slow initial page load',
        severity: 'high'
      }
    });
    
    if (findResponse.status() === 200) {
      const findData = await findResponse.json();
      
      // Step 2: If no solution found, capture new learning
      if (findData.solutions.length === 0) {
        const learnResponse = await request.post('/api/agent-intelligence/learn', {
          headers: authHeaders,
          data: {
            agentId: 'A1',
            category: 'optimization',
            domain: 'frontend',
            problem: 'Slow initial page load',
            solution: 'Implemented code splitting and lazy loading',
            outcome: {
              success: true,
              impact: 'high',
              timeSaved: '5 hours',
              metricsImproved: { 'load_time': 40 }
            },
            confidence: 0.9
          }
        });
        
        if (learnResponse.status() === 200) {
          const learnData = await learnResponse.json();
          
          // Step 3: Distribute the knowledge
          const distributeResponse = await request.post('/api/agent-intelligence/distribute-knowledge', {
            headers: authHeaders,
            data: {
              patternId: learnData.patternId,
              priority: 'high'
            }
          });
          
          expect([200, 400, 401, 403]).toContain(distributeResponse.status());
          
          // Step 4: Validate the solution
          if (distributeResponse.status() === 200) {
            const validateResponse = await request.post('/api/agent-intelligence/validate', {
              headers: authHeaders,
              data: {
                feature: 'Page Load Optimization',
                page: 'HomePage',
                targetAgent: 'A1',
                testType: 'performance'
              }
            });
            
            expect([200, 400, 401]).toContain(validateResponse.status());
          }
        }
      }
    }
  });
});

// ============================================================================
// DATABASE INTEGRATION TESTS
// ============================================================================

test.describe('Database Operations Validation', () => {
  
  test('should persist agent communications to database', async ({ request }) => {
    // Send a message
    const sendResponse = await request.post('/api/agent-communication/send', {
      headers: authHeaders,
      data: {
        fromAgentId: 'A1',
        toAgentIds: ['A2'],
        messageType: 'query',
        subject: 'Database Test',
        message: 'Testing database persistence',
        priority: 'normal',
        requiresResponse: true
      }
    });
    
    if (sendResponse.status() === 200) {
      const sendData = await sendResponse.json();
      
      // Retrieve the message
      const getResponse = await request.get('/api/agent-communication/messages/A2', {
        headers: authHeaders,
      });
      
      if (getResponse.status() === 200) {
        const getData = await getResponse.json();
        // Message should exist in database
        expect(getData.total).toBeGreaterThan(0);
      }
    }
  });

  test('should persist patterns to database', async ({ request }) => {
    // Create a pattern
    const createResponse = await request.post('/api/knowledge/pattern', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        patternName: 'Test Pattern DB',
        category: 'refactor',
        domain: 'testing',
        problemSignature: 'Test problem',
        solutionTemplate: 'Test solution',
        confidence: 0.85,
        tags: ['test', 'db']
      }
    });
    
    if (createResponse.status() === 200) {
      const createData = await createResponse.json();
      
      // Retrieve the pattern
      const getResponse = await request.get(`/api/knowledge/patterns/${createData.id}`, {
        headers: authHeaders,
      });
      
      if (getResponse.status() === 200) {
        const getData = await getResponse.json();
        expect(getData.patternName).toBe('Test Pattern DB');
      }
    }
  });

  test('should update pattern confidence over time', async ({ request }) => {
    // Create pattern
    const createResponse = await request.post('/api/knowledge/pattern', {
      headers: authHeaders,
      data: {
        agentId: 'A1',
        patternName: 'Confidence Test',
        category: 'pattern',
        domain: 'testing',
        problemSignature: 'Test',
        solutionTemplate: 'Test',
        confidence: 0.7
      }
    });
    
    if (createResponse.status() === 200) {
      const createData = await createResponse.json();
      
      // Update confidence
      const updateResponse = await request.patch(`/api/knowledge/patterns/${createData.id}`, {
        headers: authHeaders,
        data: {
          confidence: 0.95
        }
      });
      
      if (updateResponse.status() === 200) {
        const updateData = await updateResponse.json();
        expect(updateData.confidence).toBe(0.95);
      }
    }
  });

  test('should track agent performance metrics in database', async ({ request }) => {
    // Get agent performance
    const response = await request.get('/api/agent-intelligence/performance/A1', {
      headers: authHeaders,
    });
    
    if (response.status() === 200) {
      const data = await response.json();
      // Metrics should be tracked
      expect(data).toHaveProperty('metrics');
    }
  });
});

// ============================================================================
// PERFORMANCE & LOAD TESTS
// ============================================================================

test.describe('Performance & Load Handling', () => {
  
  test('should handle rapid sequential requests', async ({ request }) => {
    const requests = [];
    for (let i = 0; i < 20; i++) {
      requests.push(
        request.get('/api/learning/stats')
      );
    }
    
    const responses = await Promise.all(requests);
    const successCount = responses.filter(r => r.status() === 200).length;
    
    // Most should succeed (some may be rate limited)
    expect(successCount).toBeGreaterThan(10);
  });

  test('should cache AI responses for cost optimization', async ({ request }) => {
    const query = 'What is the capital of France?';
    
    // First request (uncached)
    const firstResponse = await request.post('/api/ai/chat', {
      headers: authHeaders,
      data: {
        query,
        priority: 'cost'
      }
    });
    
    if (firstResponse.status() === 200) {
      const firstData = await firstResponse.json();
      
      // Second identical request (should be cached)
      const secondResponse = await request.post('/api/ai/chat', {
        headers: authHeaders,
        data: {
          query,
          priority: 'cost'
        }
      });
      
      if (secondResponse.status() === 200) {
        const secondData = await secondResponse.json();
        // Second request should be faster (cached)
        expect(secondData.data.metadata.latency).toBeLessThanOrEqual(
          firstData.data.metadata.latency
        );
      }
    }
  });

  test('should handle bulk operations efficiently', async ({ request }) => {
    const startTime = Date.now();
    
    const response = await request.post('/api/ai/bulk', {
      headers: authHeaders,
      data: {
        queries: Array(5).fill('What is React?'),
        temperature: 0.7,
        maxTokens: 100
      }
    });
    
    const endTime = Date.now();
    const duration = endTime - startTime;
    
    if (response.status() === 200) {
      const data = await response.json();
      // Bulk processing should be efficient
      expect(data.data.responses).toHaveLength(5);
      // Should complete in reasonable time (adjust based on API speed)
      expect(duration).toBeLessThan(30000); // 30 seconds
    }
  });
});
