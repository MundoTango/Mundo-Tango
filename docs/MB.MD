# MB.MD v4.0 - Simultaneously, Recursively, Critically

**Last Updated:** November 14, 2025  
**Current Version:** v4.0 (Optimized Execution)  
**Project:** Mundo Tango (927 features, 47 P0 blockers)

---

## ğŸ“š Version History

| Version | Date | Key Innovation | Performance |
|---------|------|----------------|-------------|
| v1.0 | Oct 2024 | Sequential building | 180min/wave, $60/wave |
| v2.0 | Nov 2024 | Basic parallelization (2-3 subagents) | 120min/wave, $45/wave |
| v3.0 | Nov 2024 | Mega-wave (10 parallel tracks) | 165min/wave, $49/wave |
| **v4.0** | **Nov 2024** | **Batching + Templates + Memory** | **90min/wave, $32/wave** |

**v4.0 Improvement:** 45% faster, 35% cheaper than v3.0

---

## ğŸ¯ Core Principles (Unchanged)

### 1. **Simultaneously** - Parallel Execution
- Never work sequentially when parallel is possible
- Main agent + 2-9 subagents working concurrently
- Each subagent handles independent features/batches
- Maximize resource utilization (no idle time)

### 2. **Recursively** - Deep Exploration
- Comprehensive solutions, not surface-level fixes
- Explore dependencies and implications
- Build foundations that enable future features
- Think systemically about architecture

### 3. **Critically** - Rigorous Quality
- Enterprise-grade code quality
- Test-driven development (Playwright E2E)
- Security-first approach
- Performance optimization built-in

---

## âš¡ v4.0 NEW Optimizations

### **1. Micro-Batching (60% Cost Reduction)**

**Problem:** Subagent overhead dominates costs  
**Old:** 1 feature = 1 subagent ($4.50 overhead each)  
**New:** 3-4 features = 1 subagent (shared overhead)

**Example:**
```
âŒ v3.0: 9 features = 9 subagents = $40.50 overhead
âœ… v4.0: 9 features = 3 subagents = $13.50 overhead
Savings: $27 (67% reduction)
```

**Rules:**
- Batch similar-sized features together
- Micro (5-10min) + Micro + Micro = 1 subagent
- Small (15-30min) + Small + Small = 1 subagent
- Medium (45-90min) alone or + Micro features
- Large (2-4h) always alone

---

### **2. Template Reuse System (70% Time Savings)**

**Problem:** Rebuilding similar features from scratch wastes time  
**Solution:** Build once, copy forever

**Template Library (docs/patterns.md):**
- Dashboard Pattern: 60min â†’ 15min (75% faster)
- CRUD API Pattern: 40min â†’ 10min (75% faster)
- Service Pattern: 30min â†’ 8min (73% faster)
- Email Template: 20min â†’ 5min (75% faster)

**Template Promotion Process:**
1. Build feature from scratch
2. Test thoroughly, fix all bugs
3. Use in production for 1 wave
4. If stable â†’ Promote to patterns.md
5. Future features copy template

**Quality Gate:** Only battle-tested code becomes templates

---

### **3. Context Pre-Loading (20-30min/subagent)**

**Problem:** Subagents waste time exploring file structure  
**Solution:** Give exact file paths upfront

**File Map (docs/file-map.md):**
```
Need tier enforcement? â†’ server/middleware/tierEnforcement.ts
Need analytics? â†’ server/services/AnalyticsService.ts
Need admin UI? â†’ client/src/pages/admin/[Feature]Dashboard.tsx
Need encryption? â†’ server/utils/encryption.ts
```

**Subagent Task Format:**
```markdown
Task: Build Subscription Analytics Dashboard

Files to use:
- Template: client/src/pages/admin/AnalyticsDashboard.tsx
- Service: server/services/SubscriptionService.ts
- API: server/routes/subscription-routes.ts

No exploration needed - paths provided above.
```

**Savings:** 25min exploration â†’ 0min (100% elimination)

---

### **4. Zero Documentation Mode (35min/wave)**

**Problem:** Creating .md reports wastes time  
**Old:** Generate comprehensive reports after each wave  
**New:** Code only, log learnings

**What NOT to create:**
- âŒ Feature implementation reports
- âŒ Detailed changelogs  
- âŒ Verbose documentation

**What TO create:**
- âœ… Code (TypeScript, React, SQL)
- âœ… Tests (Playwright)
- âœ… Brief learnings in wave-log.md

**Exception:** MB.MD system docs (this file, patterns.md, etc.)

---

### **5. Main Agent Parallel Work (No Idle Time)**

**Problem:** Main agent waits while subagents work  
**Solution:** Main agent builds 2-3 simple features

**v3.0 Timeline:**
```
0-60min: Subagents work (main agent idle) âŒ
60-90min: Main agent tests everything
```

**v4.0 Timeline:**
```
0-60min: Subagents + Main agent all work âœ…
60-90min: Validation & testing (all parallel)
```

**Main Agent Tasks:**
- Micro features (5-10min each)
- Simple updates (add field, fix bug)
- Quick integrations
- Testing coordination

---

### **6. Smart Dependency Ordering (33% Time Savings)**

**Problem:** Building in wrong order = rebuilding later  
**Solution:** Dependency graph guides build order

**Example Waste:**
```
âŒ Random order:
  Wave 1: Email service (30min)
  Wave 5: User preferences (20min)
  Wave 7: Rebuild email to use preferences (25min)
  Total: 75min
```

**Smart Order:**
```
âœ… Foundation-first:
  Wave 1: User preferences (20min)
  Wave 2: Email service with preferences (35min)
  Total: 55min (27% savings)
```

**Dependency Graph (docs/dependency-graph.md):**
- Foundation layers identified
- Build order optimized
- Zero rebuilds

---

### **7. Parallel Testing (33% Faster)**

**Problem:** Sequential testing phase wastes time  
**Old:** Build all â†’ Test all (2 phases)  
**New:** Build + Test simultaneously

**Each subagent task includes:**
1. Build features
2. Run Playwright tests
3. Validate LSP
4. Report results
5. Fix bugs immediately

**Benefits:**
- Bugs caught when context fresh (easier to fix)
- No waiting for test phase
- Faster feedback loop
- Higher quality

---

### **8. Progressive Enhancement (Ship Faster)**

**Strategy:** MVP â†’ Enhanced â†’ Polished

**Example: GDPR Compliance**
```
Wave 8 (MVP): 
  - Essential data export
  - Basic deletion
  - Consent tracking
  Ship: 2 hours âœ…

Wave 12 (Enhanced):
  - Automated compliance reports
  - Data portability formats
  - Advanced consent management
  Ship: +1 hour

Wave 18 (Polished):
  - Multi-jurisdiction support
  - Compliance dashboard
  - Automated audits
  Ship: +1 hour
```

**Benefits:**
- Faster to P1 features
- Learn from real usage
- Avoid over-engineering

---

## ğŸ§  Memory System (Self-Improvement)

### Problem
Agent memory resets between sessions â†’ Re-explores files, rebuilds patterns, repeats mistakes

### Solution: 5-Document Memory Architecture

#### **1. docs/patterns.md** - Reusable Code Templates
- Dashboard patterns (analytics, moderation, subscription)
- CRUD API patterns (events, housing, groups)
- Service patterns (email, SMS, notifications)
- Component patterns (forms, tables, cards)

**Updated:** After each wave when new patterns emerge  
**Usage:** Copy template, customize 10-20 lines, ship

---

#### **2. docs/wave-log.md** - Learning History
- What worked well (keep doing)
- What wasted time (stop doing)
- Anti-patterns discovered
- Optimization insights
- Bug patterns

**Updated:** End of each wave  
**Usage:** Review before starting new wave

---

#### **3. docs/cost-log.md** - Cost Tracking & Predictions
- Actual costs per wave
- Cost per feature
- Cost per feature type
- Predictive modeling
- Budget forecasting

**Updated:** After each wave  
**Usage:** Cost planning, optimization decisions

---

#### **4. docs/file-map.md** - File Location Reference
- All major files cataloged
- Architecture patterns documented
- No exploration needed
- Instant file access

**Updated:** When new systems added  
**Usage:** Subagent task preparation

---

#### **5. docs/dependency-graph.md** - Build Order Optimization
- Foundation â†’ Features mapping
- Dependency chains identified
- Build order suggestions
- Rebuild avoidance

**Updated:** When new dependencies discovered  
**Usage:** Wave planning

---

## ğŸ›¡ï¸ Quality System (10-Layer Pipeline)

### Layer 1: Pre-Flight Checks
```bash
# Search before building
grep -r "similar_feature" server/
grep -r "similar_feature" client/

# If exists: Fix, don't rebuild
# If missing: Check dependencies first
```

---

### Layer 2: LSP Validation
```bash
# After writing TypeScript
get_latest_lsp_diagnostics

# Fix all type errors before proceeding
```

---

### Layer 3: Schema Validation
```bash
# Before schema changes
grep -A 5 "table_name" shared/schema.ts

# Check ID types match (serial vs varchar)
# Verify foreign keys exist
# Push safely
npm run db:push --force
```

---

### Layer 4: Playwright E2E Tests
```typescript
// Every P0 blocker gets test plan
Test Plan:
1. [Browser] Navigate to feature
2. [Verify] UI renders correctly
3. [Verify] Data loads from API
4. [Browser] Test user interactions
5. [Verify] State updates correctly
6. [Verify] Error states work
7. [Verify] Empty states work
```

---

### Layer 5: Regression Tests
```bash
# After changes, test existing features
Changed auth? â†’ Re-test login, signup
Changed schema? â†’ Re-test all CRUD
Changed middleware? â†’ Re-test protected routes
```

---

### Layer 6: Code Review Checklist
```
âœ… TypeScript compiles (LSP clean)
âœ… Database migration successful
âœ… API routes return correct codes
âœ… Frontend renders without errors
âœ… Loading states exist
âœ… Error states exist
âœ… Empty states exist
âœ… Permissions enforced
âœ… Playwright test passes
âœ… No console.log() left
```

---

### Layer 7: Runtime Validation
```bash
# Restart workflow
restart_workflow

# Check logs
refresh_all_logs

# Verify no errors
```

---

### Layer 8: Error Catalog
```markdown
# Document bugs found
âŒ Bug: Dashboard crashed on empty data
âœ… Fix: Added empty state
ğŸ“ Prevention: Add to dashboard template
```

---

### Layer 9: Template Validation
```
Only promote to patterns.md if:
âœ… Used in production 1+ wave
âœ… Zero bugs found
âœ… Reusable across features
âœ… Well-documented
```

---

### Layer 10: Continuous Monitoring
```bash
# Post-deployment validation
- Visit main pages
- Check console for errors
- Verify API responses
- Run smoke tests
```

---

## ğŸ’° Cost Optimization

### What's Expensive
- **$$$** Long-running subagents with thinking time
- **$$** Multiple small file writes
- **$** Heavy LSP checks on large files

### What's Cheap
- **$** Main agent planning (Plan mode)
- **$** Batch file operations
- **$** Template copying
- **$** Subagent execution (no thinking)

### Optimization Strategy
1. âœ… Main agent does ALL thinking (Plan mode = cheaper)
2. âœ… Subagents only execute (Build mode, no thinking)
3. âœ… Batch all file operations
4. âœ… Reuse templates aggressively
5. âœ… Micro-batch features to share overhead

### Cost Floor Reality
âš ï¸ **Cannot go below ~$25/session** (Replit platform overhead)  
âœ… **Can double features per session** (6-8 instead of 3-4)  
âœ… **Target: $25-35/wave average** (vs $40-50 v3.0 baseline)

---

## ğŸ”§ Replit-Specific Optimizations

### 1. Auto-Restart Workflow
```markdown
Each subagent task includes:
1. Make code changes
2. restart_workflow (automatic)
3. refresh_all_logs
4. Verify no errors
5. Report success
```

### 2. Database Introspection
```sql
-- Before schema changes
SHOW TABLES;
DESCRIBE table_name;

-- Know exact current state
-- Avoid breaking migrations
```

### 3. Checkpoint Strategy
```
Before wave: Replit auto-creates checkpoint âœ…
During wave: Validate continuously âœ…
If breaks: suggest_rollback (<5min recovery) âœ…
After wave: Checkpoint = "known good state" âœ…
```

### 4. Secrets Pre-Check
```typescript
// Wave start
check_secrets(['STRIPE_KEY', 'SUPABASE_URL']);

// If missing: Ask once
// Never block mid-wave
```

---

## ğŸ“ Feature Sizing & Bundling

### Size Classifications

**Micro (5-10min):**
- Add field to form
- Update validation rule
- New email template
- Fix small bug

**Small (15-30min):**
- Simple CRUD page
- Basic API endpoint
- Simple dashboard
- Component update

**Medium (45-90min):**
- Complex dashboard with charts
- Multi-step workflow
- Service with business logic
- Feature integration

**Large (2-4h):**
- AI agent system
- Complete feature area
- Complex integrations
- Major refactor

### Bundling Strategy

**Maximize subagent utilization:**
```
Subagent 1: 3 small features (60min)
Subagent 2: 1 medium + 2 micro (60min)
Main Agent: 4 micro features (40min)

Result: All complete in 60min parallel
```

---

## ğŸ“Š Performance Metrics

### Historical Performance

**Wave 7 (v3.0 - Mega-Wave):**
- Duration: 165 minutes
- Cost: $49.65
- Features: 9 P0 blockers
- Per feature: $5.52, 18min
- Efficiency: 10 parallel tracks (overhead too high)

**Wave 8 Target (v4.0 - Optimized):**
- Duration: 90 minutes (45% faster)
- Cost: $32 (35% cheaper)
- Features: 8 P0 blockers
- Per feature: $4, 11min
- Efficiency: 3 batches (micro-batched)

**Future Waves (v4.0 Optimized with Templates):**
- Duration: 75-90 minutes
- Cost: $25-35
- Features: 8-10 per wave
- Per feature: $2.50-4
- Efficiency: Template reuse + batching

### Quality Metrics

**Wave 7 (No systematic testing):**
- Bug ratio: ~1.3 bugs per feature
- Post-wave fixes: 2+ hours

**Wave 8+ Target (With quality system):**
- Bug ratio: <0.3 bugs per feature (75% reduction)
- Post-wave fixes: <30min
- Playwright coverage: 95% on P0/P1

---

## ğŸ¯ Success Criteria

### Velocity
- âœ… 75-90min per wave (vs 165min baseline)
- âœ… 8-10 features per wave (vs 6-8)
- âœ… 45% faster than v3.0

### Cost
- âœ… $25-35 per wave (vs $45-50)
- âœ… $2.50-4 per feature (vs $5.52)
- âœ… 35% cheaper than v3.0

### Quality
- âœ… <0.3 bugs per feature
- âœ… 95% test coverage
- âœ… Zero breaking changes
- âœ… All migrations reversible

### Learning
- âœ… Memory system updated each wave
- âœ… New patterns documented
- âœ… Anti-patterns cataloged
- âœ… Continuous improvement

---

## ğŸš€ Execution Checklist

### Before Wave Start
- [ ] Review wave-log.md (learn from past)
- [ ] Review patterns.md (identify reusable templates)
- [ ] Review dependency-graph.md (optimal build order)
- [ ] Check database status
- [ ] Verify all tests passing
- [ ] Create wave task list

### During Wave
- [ ] Micro-batch features (3-4 per subagent)
- [ ] Pre-load context (exact file paths)
- [ ] Main agent works in parallel
- [ ] Each subagent tests immediately
- [ ] Document learnings as you go

### After Wave
- [ ] Validate all features work
- [ ] Run regression tests
- [ ] Update wave-log.md
- [ ] Update cost-log.md  
- [ ] Promote new patterns to patterns.md
- [ ] Update file-map.md if needed
- [ ] Restart workflow, verify clean
- [ ] Update replit.md progress

---

## ğŸ“ Next Evolution (v5.0 Ideas)

Potential future improvements:
- AI-powered cost prediction (per feature estimate)
- Automated pattern detection (suggest templates)
- Smart test generation (AI writes Playwright tests)
- Parallel wave execution (2 waves simultaneously)
- Cross-project pattern library (reuse across projects)

---

**MB.MD v4.0 - Built for speed, cost efficiency, and continuous learning** ğŸš€
