╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║     MUNDO TANGO - REPLIT + SUPABASE EXECUTION PLAN                ║
║          Complete Build Guide (Phase 3 → Production)              ║
║                                                                   ║
║         Build Time: 1-2 Days (with quality patterns)              ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝

VERSION: 1.0
CREATED: October 30, 2025
ARCHITECTURE: Replit (Hosting) + Supabase (Backend Services)
METHOD: MB.MD + Shift-Left Quality
STARTING POINT: Phase 2 Complete ✅

=======================================================================
🎯 CURRENT STATUS: PHASE 2 COMPLETE
=======================================================================

**What You Have (Phase 2 Complete):**
✅ Replit environment set up
✅ Node.js + PostgreSQL configured
✅ Frontend framework (React + Vite)
✅ Core routing structure
✅ Design system foundations

**What's Next:**
→ Phase 3: Supabase Integration + Features (1-2 days)
→ Phase 4: Cross-Cutting Polish (4 hours)
→ Phase 5: Deploy to Production (2 hours)

=======================================================================
🏗️ ARCHITECTURE OVERVIEW
=======================================================================

**Your Complete Stack:**

┌─────────────────────────────────────────────────────────┐
│                    REPLIT (Hosting)                      │
├─────────────────────────────────────────────────────────┤
│  • React Frontend (client/src/*)                         │
│  • Express API Server (server/*.ts)                      │
│  • Custom Business Logic (AI, Analytics)                 │
│  • Deployment & Hosting                                  │
└────────────┬────────────────────────────────────────────┘
             │
             ├──→ SUPABASE (Backend Services)
             │      • PostgreSQL Database (all data)
             │      • Authentication (users, sessions)
             │      • Storage (images, videos, files)
             │      • Real-time (WebSocket subscriptions)
             │      • Row Level Security (RLS)
             │
             ├──→ EXTERNAL SERVICES
             │      • Stripe (payments)
             │      • OpenAI/Anthropic/Groq (AI)
             │      • Resend (email)
             │
             └──→ REPLIT SERVICES
                    • Secrets Management
                    • Deployment
                    • Database (optional backup)

**Key Decisions:**
✅ Database: Supabase PostgreSQL (not Replit DB)
✅ Auth: Supabase Auth (built-in, secure)
✅ Storage: Supabase Storage (file uploads)
✅ Real-time: Supabase Realtime (WebSocket)
✅ Hosting: Replit (frontend + custom API)
✅ Custom Logic: Your Express API (AI, payments, analytics)

=======================================================================
PHASE 3: SUPABASE INTEGRATION + FEATURES (1-2 DAYS)
=======================================================================

**Purpose**: Set up Supabase backend + build all 8 core features

**Timeline**: 1-2 days (with quality patterns integrated)
**Strategy**: MB.MD Phased Parallelization + Shift-Left Quality

---

### 3.0: SUPABASE SETUP (1-2 HOURS) ⭐ CRITICAL FIRST STEP

**DO THIS BEFORE BUILDING ANY FEATURES**

---

#### Step 3.0.1: Create Supabase Project (15 min)

**Actions:**
1. Go to https://supabase.com
2. Sign up/login (use GitHub for easy OAuth)
3. Click "New Project"
4. Configure:
   - Name: "mundo-tango"
   - Database Password: (generate strong password, save it!)
   - Region: Choose closest to your users
   - Plan: Free tier (for now)
5. Wait 2-3 minutes for project to provision

**What You'll Get:**
- Project URL: `https://xxxxx.supabase.co`
- Anon Key: `eyJhbGc...` (public, safe for frontend)
- Service Role Key: `eyJhbGc...` (secret, backend only)

---

#### Step 3.0.2: Add Supabase Secrets to Replit (5 min)

**In Replit:**
1. Open Secrets panel (🔒 lock icon in sidebar)
2. Add these secrets:

```
SUPABASE_URL=https://xxxxx.supabase.co
SUPABASE_ANON_KEY=eyJhbGc... (from Supabase dashboard)
SUPABASE_SERVICE_ROLE_KEY=eyJhbGc... (from Supabase dashboard)

# Also add for frontend (Vite):
VITE_SUPABASE_URL=https://xxxxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGc...
```

**Security Note:** 
- Anon key: Safe for frontend (has RLS restrictions)
- Service role key: NEVER expose to frontend (bypasses RLS)

---

#### Step 3.0.3: Install Supabase Client (5 min)

**Run in Replit shell:**
```bash
npm install @supabase/supabase-js
npm install @supabase/auth-helpers-react  # For React hooks
```

---

#### Step 3.0.4: Create Supabase Client Files (15 min)

**File: `client/src/lib/supabase.ts`**
```typescript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
})

// TypeScript types (will define after creating tables)
export type Database = {
  public: {
    Tables: {
      // Will fill in after creating tables
    }
  }
}
```

**File: `server/lib/supabase.ts`** (backend client)
```typescript
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.SUPABASE_URL!
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing Supabase environment variables')
}

// Backend client with service role (bypasses RLS)
export const supabaseAdmin = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
})
```

---

#### Step 3.0.5: Create Database Schema in Supabase (30 min)

**Open Supabase Dashboard → SQL Editor**

Run this SQL to create all tables:

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (Supabase Auth creates auth.users, we extend it)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username VARCHAR(50) UNIQUE NOT NULL,
  full_name VARCHAR(255),
  avatar_url TEXT,
  bio TEXT,
  city VARCHAR(100),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Posts table
CREATE TABLE public.posts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  image_url TEXT,
  video_url TEXT,
  visibility VARCHAR(20) DEFAULT 'public', -- public, friends, private
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Likes table
CREATE TABLE public.likes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  post_id UUID REFERENCES public.posts(id) ON DELETE CASCADE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, post_id)
);

-- Comments table
CREATE TABLE public.comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  post_id UUID REFERENCES public.posts(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Events table
CREATE TABLE public.events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  start_date TIMESTAMP WITH TIME ZONE NOT NULL,
  end_date TIMESTAMP WITH TIME ZONE,
  location VARCHAR(255),
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  image_url TEXT,
  category VARCHAR(50),
  max_attendees INTEGER,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- RSVPs table
CREATE TABLE public.rsvps (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
  status VARCHAR(20) DEFAULT 'going', -- going, maybe, not_going
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, event_id)
);

-- Communities table
CREATE TABLE public.communities (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  image_url TEXT,
  city VARCHAR(100),
  is_private BOOLEAN DEFAULT false,
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Community memberships table
CREATE TABLE public.community_members (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  community_id UUID REFERENCES public.communities(id) ON DELETE CASCADE NOT NULL,
  role VARCHAR(20) DEFAULT 'member', -- admin, moderator, member
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, community_id)
);

-- Messages table (for real-time chat)
CREATE TABLE public.messages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  conversation_id UUID NOT NULL,
  sender_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  read_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Conversations table
CREATE TABLE public.conversations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  is_group BOOLEAN DEFAULT false,
  name VARCHAR(255), -- for group chats
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Conversation participants
CREATE TABLE public.conversation_participants (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  conversation_id UUID REFERENCES public.conversations(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(conversation_id, user_id)
);

-- Subscriptions table (for Stripe)
CREATE TABLE public.subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  stripe_customer_id VARCHAR(255),
  stripe_subscription_id VARCHAR(255),
  plan VARCHAR(50), -- free, pro, enterprise
  status VARCHAR(50), -- active, canceled, past_due
  current_period_start TIMESTAMP WITH TIME ZONE,
  current_period_end TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- AI conversations table (for Mr Blue)
CREATE TABLE public.ai_conversations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  messages JSONB NOT NULL DEFAULT '[]',
  context JSONB,
  total_tokens INTEGER DEFAULT 0,
  total_cost DECIMAL(10, 4) DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for performance
CREATE INDEX idx_posts_user_id ON public.posts(user_id);
CREATE INDEX idx_posts_created_at ON public.posts(created_at DESC);
CREATE INDEX idx_likes_post_id ON public.likes(post_id);
CREATE INDEX idx_comments_post_id ON public.comments(post_id);
CREATE INDEX idx_events_start_date ON public.events(start_date);
CREATE INDEX idx_events_city ON public.events(city);
CREATE INDEX idx_messages_conversation_id ON public.messages(conversation_id);
CREATE INDEX idx_messages_created_at ON public.messages(created_at DESC);

-- Enable Row Level Security on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.rsvps ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.communities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.community_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.conversation_participants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ai_conversations ENABLE ROW LEVEL SECURITY;

-- RLS Policies for profiles (everyone can read, users can update own)
CREATE POLICY "Public profiles are viewable by everyone"
  ON public.profiles FOR SELECT
  USING (true);

CREATE POLICY "Users can update own profile"
  ON public.profiles FOR UPDATE
  USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
  ON public.profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

-- RLS Policies for posts
CREATE POLICY "Posts are viewable by everyone"
  ON public.posts FOR SELECT
  USING (visibility = 'public' OR user_id = auth.uid());

CREATE POLICY "Users can insert own posts"
  ON public.posts FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own posts"
  ON public.posts FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own posts"
  ON public.posts FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for likes
CREATE POLICY "Likes are viewable by everyone"
  ON public.likes FOR SELECT
  USING (true);

CREATE POLICY "Users can insert own likes"
  ON public.likes FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own likes"
  ON public.likes FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for comments (similar pattern)
CREATE POLICY "Comments are viewable by everyone"
  ON public.comments FOR SELECT
  USING (true);

CREATE POLICY "Users can insert own comments"
  ON public.comments FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own comments"
  ON public.comments FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own comments"
  ON public.comments FOR DELETE
  USING (auth.uid() = user_id);

-- RLS Policies for events
CREATE POLICY "Events are viewable by everyone"
  ON public.events FOR SELECT
  USING (true);

CREATE POLICY "Users can insert own events"
  ON public.events FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own events"
  ON public.events FOR UPDATE
  USING (auth.uid() = user_id);

-- RLS Policies for messages (only conversation participants)
CREATE POLICY "Users can view messages in their conversations"
  ON public.messages FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.conversation_participants
      WHERE conversation_id = messages.conversation_id
        AND user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert messages in their conversations"
  ON public.messages FOR INSERT
  WITH CHECK (
    auth.uid() = sender_id AND
    EXISTS (
      SELECT 1 FROM public.conversation_participants
      WHERE conversation_id = messages.conversation_id
        AND user_id = auth.uid()
    )
  );

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers for updated_at
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON public.profiles
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_posts_updated_at BEFORE UPDATE ON public.posts
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_events_updated_at BEFORE UPDATE ON public.events
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Function to create profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username, full_name, avatar_url)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'username', NEW.email),
    COALESCE(NEW.raw_user_meta_data->>'full_name', ''),
    COALESCE(NEW.raw_user_meta_data->>'avatar_url', '')
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to create profile on signup
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

**Validation:**
✅ Go to Supabase Dashboard → Table Editor
✅ Verify all 13 tables created
✅ Check indexes exist
✅ Verify RLS enabled (green checkmark)

---

#### Step 3.0.6: Set Up Supabase Storage (15 min)

**In Supabase Dashboard → Storage:**

1. Create buckets:
   - **avatars** (public)
   - **posts** (public)
   - **events** (public)
   - **messages** (private)

2. Set policies for each bucket:

**For public buckets (avatars, posts, events):**
```sql
-- Allow anyone to view
CREATE POLICY "Public images are viewable by everyone"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'avatars');

-- Allow authenticated users to upload
CREATE POLICY "Authenticated users can upload avatars"
  ON storage.objects FOR INSERT
  WITH CHECK (bucket_id = 'avatars' AND auth.role() = 'authenticated');

-- Allow users to update own files
CREATE POLICY "Users can update own avatars"
  ON storage.objects FOR UPDATE
  USING (bucket_id = 'avatars' AND auth.uid() = owner);
```

Repeat for 'posts' and 'events' buckets.

---

#### Step 3.0.7: Enable Supabase Realtime (5 min)

**In Supabase Dashboard → Database → Replication:**

Enable realtime for these tables:
- ✅ messages (for real-time chat)
- ✅ likes (for live like counts)
- ✅ comments (for live comments)
- ✅ conversation_participants (for presence)

---

#### Step 3.0.8: Test Supabase Connection (10 min)

**Create test file: `server/test-supabase.ts`**
```typescript
import { supabaseAdmin } from './lib/supabase'

async function testConnection() {
  try {
    // Test database connection
    const { data, error } = await supabaseAdmin
      .from('profiles')
      .select('*')
      .limit(1)
    
    if (error) throw error
    
    console.log('✅ Supabase connected successfully!')
    console.log('Database response:', data)
  } catch (error) {
    console.error('❌ Supabase connection failed:', error)
  }
}

testConnection()
```

**Run:**
```bash
npx tsx server/test-supabase.ts
```

**Expected output:**
```
✅ Supabase connected successfully!
Database response: []
```

---

**PHASE 3.0 COMPLETE**: ✅ Supabase fully integrated and tested

**Validation Gate:**
❌ Cannot proceed if:
  - Tables not created
  - Connection test fails
  - Storage buckets not configured
  - Realtime not enabled

✅ Proceed to Phase 3.1 when ALL validated

---

### 3.1: AUTHENTICATION (2-3 HOURS)

**Using Supabase Auth (built-in, secure, production-ready)**

---

#### Step 3.1.1: Configure Auth Providers (15 min)

**In Supabase Dashboard → Authentication → Providers:**

Enable providers:
1. ✅ **Email** (default, already enabled)
2. ✅ **Google OAuth** (recommended)
   - Get credentials from Google Cloud Console
   - Add redirect URL: `https://xxxxx.supabase.co/auth/v1/callback`
3. ✅ **GitHub OAuth** (optional)
   - Get credentials from GitHub Developer Settings
4. Configure email templates (optional but recommended)

---

#### Step 3.1.2: Create Auth Context (30 min)

**File: `client/src/contexts/AuthContext.tsx`**
```typescript
import { createContext, useContext, useEffect, useState } from 'react'
import { User, Session } from '@supabase/supabase-js'
import { supabase } from '@/lib/supabase'

interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signUp: (email: string, password: string, userData?: any) => Promise<void>
  signIn: (email: string, password: string) => Promise<void>
  signInWithGoogle: () => Promise<void>
  signOut: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      (_event, session) => {
        setSession(session)
        setUser(session?.user ?? null)
        setLoading(false)
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  const signUp = async (email: string, password: string, userData?: any) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: userData, // username, full_name, etc.
      },
    })
    if (error) throw error
  }

  const signIn = async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })
    if (error) throw error
  }

  const signInWithGoogle = async () => {
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo: `${window.location.origin}/auth/callback`,
      },
    })
    if (error) throw error
  }

  const signOut = async () => {
    const { error } = await supabase.auth.signOut()
    if (error) throw error
  }

  return (
    <AuthContext.Provider
      value={{
        user,
        session,
        loading,
        signUp,
        signIn,
        signInWithGoogle,
        signOut,
      }}
    >
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  return context
}
```

---

#### Step 3.1.3: Create Auth Pages (1 hour)

**File: `client/src/pages/LoginPage.tsx`**
```typescript
import { useState } from 'react'
import { useNavigate } from 'wouter'
import { useAuth } from '@/contexts/AuthContext'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Card } from '@/components/ui/card'
import { useToast } from '@/hooks/use-toast'

export function LoginPage() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [loading, setLoading] = useState(false)
  const { signIn, signInWithGoogle } = useAuth()
  const [, navigate] = useNavigate()
  const { toast } = useToast()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setLoading(true)
    
    try {
      await signIn(email, password)
      toast({ title: 'Success!', description: 'Logged in successfully' })
      navigate('/feed')
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive',
      })
    } finally {
      setLoading(false)
    }
  }

  const handleGoogleLogin = async () => {
    try {
      await signInWithGoogle()
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive',
      })
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-cyan-50 dark:from-gray-900 dark:to-gray-800">
      <Card className="w-full max-w-md p-8">
        <h1 className="text-3xl font-bold text-center mb-6">
          Welcome to Mundo Tango
        </h1>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
              data-testid="input-email"
            />
          </div>
          
          <div>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              data-testid="input-password"
            />
          </div>
          
          <Button
            type="submit"
            className="w-full"
            disabled={loading}
            data-testid="button-login"
          >
            {loading ? 'Logging in...' : 'Log In'}
          </Button>
        </form>
        
        <div className="relative my-6">
          <div className="absolute inset-0 flex items-center">
            <span className="w-full border-t" />
          </div>
          <div className="relative flex justify-center text-xs uppercase">
            <span className="bg-background px-2 text-muted-foreground">
              Or continue with
            </span>
          </div>
        </div>
        
        <Button
          type="button"
          variant="outline"
          className="w-full"
          onClick={handleGoogleLogin}
          data-testid="button-google-login"
        >
          <svg className="mr-2 h-4 w-4" viewBox="0 0 24 24">
            {/* Google icon SVG */}
          </svg>
          Google
        </Button>
        
        <p className="text-center text-sm text-muted-foreground mt-4">
          Don't have an account?{' '}
          <a href="/register" className="text-primary hover:underline">
            Sign up
          </a>
        </p>
      </Card>
    </div>
  )
}
```

**File: `client/src/pages/RegisterPage.tsx`** (similar structure)

**File: `client/src/pages/AuthCallbackPage.tsx`** (handles OAuth redirects)

---

#### Step 3.1.4: Protected Routes (30 min)

**File: `client/src/components/ProtectedRoute.tsx`**
```typescript
import { useAuth } from '@/contexts/AuthContext'
import { Redirect } from 'wouter'

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { user, loading } = useAuth()

  if (loading) {
    return <div>Loading...</div> // Or your loading component
  }

  if (!user) {
    return <Redirect to="/login" />
  }

  return <>{children}</>
}
```

**Update `App.tsx`:**
```typescript
import { AuthProvider } from '@/contexts/AuthContext'
import { ProtectedRoute } from '@/components/ProtectedRoute'

function App() {
  return (
    <AuthProvider>
      <Switch>
        <Route path="/login" component={LoginPage} />
        <Route path="/register" component={RegisterPage} />
        <Route path="/auth/callback" component={AuthCallbackPage} />
        
        <Route path="/feed">
          <ProtectedRoute>
            <FeedPage />
          </ProtectedRoute>
        </Route>
        
        {/* All protected routes */}
      </Switch>
    </AuthProvider>
  )
}
```

---

**PHASE 3.1 COMPLETE**: ✅ Authentication system working

**Validation:**
✅ Can register new account
✅ Can login with email/password
✅ Can login with Google OAuth
✅ Protected routes redirect to login
✅ User session persists on refresh

---

### 3.2: POSTS & FEED (4-6 HOURS)

**Build with quality patterns from start**

---

#### Quality Checklist (Mandatory):
□ i18n: All strings use translation keys
□ a11y: ARIA labels on all interactive elements
□ Tests: Unit tests + E2E test for post creation
□ Security: Content sanitized (XSS prevention)
□ Mobile: Responsive, touch-friendly
□ Performance: Image lazy loading, virtual scroll

---

#### Step 3.2.1: Post Composer Component (1 hour)

**File: `client/src/components/posts/PostComposer.tsx`**
```typescript
import { useState } from 'react'
import { useAuth } from '@/contexts/AuthContext'
import { supabase } from '@/lib/supabase'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { useToast } from '@/hooks/use-toast'
import { ImagePlus, Loader2 } from 'lucide-react'

export function PostComposer() {
  const [content, setContent] = useState('')
  const [image, setImage] = useState<File | null>(null)
  const [imagePreview, setImagePreview] = useState<string | null>(null)
  const [loading, setLoading] = useState(false)
  const { user } = useAuth()
  const { toast } = useToast()

  const handleImageSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      setImage(file)
      setImagePreview(URL.createObjectURL(file))
    }
  }

  const uploadImage = async (file: File): Promise<string> => {
    const fileExt = file.name.split('.').pop()
    const fileName = `${user!.id}-${Date.now()}.${fileExt}`
    
    const { error: uploadError, data } = await supabase.storage
      .from('posts')
      .upload(fileName, file)
    
    if (uploadError) throw uploadError
    
    const { data: { publicUrl } } = supabase.storage
      .from('posts')
      .getPublicUrl(fileName)
    
    return publicUrl
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!content.trim() && !image) return
    
    setLoading(true)
    
    try {
      let imageUrl = null
      
      // Upload image if present
      if (image) {
        imageUrl = await uploadImage(image)
      }
      
      // Create post
      const { error } = await supabase
        .from('posts')
        .insert({
          user_id: user!.id,
          content: content.trim(),
          image_url: imageUrl,
        })
      
      if (error) throw error
      
      // Reset form
      setContent('')
      setImage(null)
      setImagePreview(null)
      
      toast({ title: 'Success!', description: 'Post created successfully' })
    } catch (error: any) {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive',
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="bg-white dark:bg-gray-800 rounded-lg p-4 shadow">
      <Textarea
        placeholder="What's on your mind?"
        value={content}
        onChange={(e) => setContent(e.target.value)}
        className="mb-3 min-h-[100px]"
        data-testid="textarea-post-content"
        aria-label="Post content"
      />
      
      {imagePreview && (
        <div className="mb-3 relative">
          <img
            src={imagePreview}
            alt="Preview"
            className="rounded-lg max-h-64 w-auto"
          />
          <Button
            type="button"
            variant="destructive"
            size="sm"
            className="absolute top-2 right-2"
            onClick={() => {
              setImage(null)
              setImagePreview(null)
            }}
            aria-label="Remove image"
          >
            Remove
          </Button>
        </div>
      )}
      
      <div className="flex items-center justify-between">
        <label
          htmlFor="image-upload"
          className="cursor-pointer text-primary hover:text-primary/80"
        >
          <ImagePlus className="w-6 h-6" />
          <input
            id="image-upload"
            type="file"
            accept="image/*"
            className="hidden"
            onChange={handleImageSelect}
            data-testid="input-image-upload"
          />
        </label>
        
        <Button
          type="submit"
          disabled={loading || (!content.trim() && !image)}
          data-testid="button-submit-post"
        >
          {loading ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Posting...
            </>
          ) : (
            'Post'
          )}
        </Button>
      </div>
    </form>
  )
}
```

---

#### Step 3.2.2: Post Card Component (1 hour)

**File: `client/src/components/posts/PostCard.tsx`**
```typescript
import { useState } from 'react'
import { supabase } from '@/lib/supabase'
import { useAuth } from '@/contexts/AuthContext'
import { Button } from '@/components/ui/button'
import { Heart, MessageCircle, Share2 } from 'lucide-react'
import { formatDistanceToNow } from 'date-fns'

interface Post {
  id: string
  content: string
  image_url: string | null
  created_at: string
  user_id: string
  profiles: {
    username: string
    avatar_url: string | null
  }
  likes: { user_id: string }[]
  comments: { id: string }[]
}

export function PostCard({ post }: { post: Post }) {
  const { user } = useAuth()
  const [liked, setLiked] = useState(
    post.likes.some(like => like.user_id === user?.id)
  )
  const [likeCount, setLikeCount] = useState(post.likes.length)

  const handleLike = async () => {
    if (!user) return
    
    try {
      if (liked) {
        // Unlike
        await supabase
          .from('likes')
          .delete()
          .eq('user_id', user.id)
          .eq('post_id', post.id)
        
        setLiked(false)
        setLikeCount(prev => prev - 1)
      } else {
        // Like
        await supabase
          .from('likes')
          .insert({ user_id: user.id, post_id: post.id })
        
        setLiked(true)
        setLikeCount(prev => prev + 1)
      }
    } catch (error) {
      console.error('Error toggling like:', error)
    }
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
      {/* User info */}
      <div className="flex items-center mb-3">
        <img
          src={post.profiles.avatar_url || '/default-avatar.png'}
          alt={post.profiles.username}
          className="w-10 h-10 rounded-full mr-3"
        />
        <div>
          <p className="font-semibold">{post.profiles.username}</p>
          <p className="text-sm text-muted-foreground">
            {formatDistanceToNow(new Date(post.created_at), { addSuffix: true })}
          </p>
        </div>
      </div>
      
      {/* Content */}
      <p className="mb-3 whitespace-pre-wrap">{post.content}</p>
      
      {/* Image */}
      {post.image_url && (
        <img
          src={post.image_url}
          alt="Post image"
          className="rounded-lg w-full mb-3"
          loading="lazy"
        />
      )}
      
      {/* Actions */}
      <div className="flex items-center gap-4 text-muted-foreground">
        <Button
          variant="ghost"
          size="sm"
          onClick={handleLike}
          className={liked ? 'text-red-500' : ''}
          data-testid={`button-like-${post.id}`}
          aria-label={liked ? 'Unlike post' : 'Like post'}
        >
          <Heart className={`w-5 h-5 mr-1 ${liked ? 'fill-current' : ''}`} />
          {likeCount}
        </Button>
        
        <Button
          variant="ghost"
          size="sm"
          data-testid={`button-comment-${post.id}`}
          aria-label="Comment on post"
        >
          <MessageCircle className="w-5 h-5 mr-1" />
          {post.comments.length}
        </Button>
        
        <Button
          variant="ghost"
          size="sm"
          data-testid={`button-share-${post.id}`}
          aria-label="Share post"
        >
          <Share2 className="w-5 h-5" />
        </Button>
      </div>
    </div>
  )
}
```

---

#### Step 3.2.3: Feed Page (1 hour)

**File: `client/src/pages/FeedPage.tsx`**
```typescript
import { useEffect, useState } from 'react'
import { supabase } from '@/lib/supabase'
import { PostComposer } from '@/components/posts/PostComposer'
import { PostCard } from '@/components/posts/PostCard'
import { Loader2 } from 'lucide-react'

export function FeedPage() {
  const [posts, setPosts] = useState<any[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetchPosts()
    
    // Subscribe to real-time updates
    const channel = supabase
      .channel('posts-feed')
      .on(
        'postgres_changes',
        { event: 'INSERT', schema: 'public', table: 'posts' },
        (payload) => {
          setPosts(prev => [payload.new, ...prev])
        }
      )
      .subscribe()
    
    return () => {
      supabase.removeChannel(channel)
    }
  }, [])

  const fetchPosts = async () => {
    try {
      const { data, error } = await supabase
        .from('posts')
        .select(`
          *,
          profiles:user_id (username, avatar_url),
          likes (user_id),
          comments (id)
        `)
        .order('created_at', { ascending: false })
        .limit(20)
      
      if (error) throw error
      setPosts(data || [])
    } catch (error) {
      console.error('Error fetching posts:', error)
    } finally {
      setLoading(false)
    }
  }

  if (loading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin" />
      </div>
    )
  }

  return (
    <div className="max-w-2xl mx-auto p-4 space-y-4">
      <PostComposer />
      
      <div className="space-y-4">
        {posts.map(post => (
          <PostCard key={post.id} post={post} />
        ))}
      </div>
    </div>
  )
}
```

---

**Continue with remaining 6 features following the same pattern...**

Due to length constraints, I'll provide the complete structure for all features. The pattern is:
1. Create Supabase queries
2. Build components with quality patterns
3. Add real-time subscriptions where needed
4. Test thoroughly

---

### 3.3: EVENTS (4-6 HOURS)
### 3.4: COMMUNITIES (4-6 HOURS)
### 3.5: REAL-TIME MESSAGING (6-8 HOURS)
### 3.6: FILE UPLOADS (4-6 HOURS) - Using Supabase Storage
### 3.7: AI INTELLIGENCE (6-8 HOURS) - Custom API on Replit
### 3.8: STRIPE PAYMENTS (4-6 HOURS)

---

**PHASE 3 COMPLETE**: ✅ All features built with quality integrated

=======================================================================
PHASE 4: CROSS-CUTTING POLISH (4 HOURS)
=======================================================================

### 4.1: i18n Translation Generation (1 hour)
### 4.2: Component Library Standardization (1 hour)
### 4.3: Integration Testing (1 hour)
### 4.4: Performance Optimization (1 hour)

=======================================================================
PHASE 5: DEPLOY TO PRODUCTION (2 HOURS)
=======================================================================

### 5.1: Pre-Deployment Checklist
### 5.2: Deploy to Replit (1-click)
### 5.3: Smoke Tests
### 5.4: Monitoring Setup

=======================================================================
END OF EXECUTION PLAN
=======================================================================

**Total Build Time**: 1.5-2 days (features) + 4 hours (polish) + 2 hours (deploy)
**Result**: Production-ready Mundo Tango platform on Replit + Supabase

**Next Steps:**
1. Start with Phase 3.0 (Supabase Setup)
2. Build features in parallel with quality patterns
3. Polish and deploy

Ready to build! 🚀