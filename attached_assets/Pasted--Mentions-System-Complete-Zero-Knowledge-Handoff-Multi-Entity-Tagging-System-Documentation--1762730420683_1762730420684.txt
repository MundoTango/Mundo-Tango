# @Mentions System - Complete Zero-Knowledge Handoff
**Multi-Entity Tagging System Documentation**

## Document Overview
This document provides comprehensive documentation for the @Mentions system, enabling users to tag other users, events, groups, and cities in posts and comments throughout the platform.

**Document Statistics:**
- **Size:** Complete production-ready documentation
- **Last Updated:** January 9, 2025
- **Completeness:** 100% zero-knowledge reconstruction capability

**Purpose:** Enable any developer to fully understand and implement the @Mentions system without access to the original codebase.

---

## Table of Contents
1. [Executive Summary](#1-executive-summary)
2. [System Architecture](#2-system-architecture)
3. [SimpleMentionsInput Component](#3-simplemensionsinput-component)
4. [Token System & Parsing](#4-token-system)
5. [Database Schema](#5-database-schema)
6. [Backend API Endpoints](#6-backend-api)
7. [User Interaction Flows](#7-user-flows)
8. [Notifications Integration](#8-notifications)
9. [Visual Styling & Theming](#9-visual-styling)
10. [Multi-Entity Support](#10-multi-entity-support)
11. [Autocomplete Dropdown](#11-autocomplete-dropdown)
12. [Feed Algorithm Integration](#12-feed-algorithm)
13. [Performance & Optimization](#13-performance)
14. [Testing & Validation](#14-testing)
15. [Production Deployment](#15-deployment)

---

## 1. Executive Summary

### 1.1 System Purpose

The @Mentions system provides a unified tagging mechanism across the entire platform, allowing users to reference and notify other entities (users, events, groups, cities) within their content.

### 1.2 Key Features

âœ… **4 Mention Types** - Users, Events, Groups, Cities  
âœ… **Real-time Autocomplete** - Instant search as user types  
âœ… **Rich Visual Badges** - Color-coded by entity type  
âœ… **Token-Based Parsing** - Sophisticated text parsing engine  
âœ… **Notification System** - Auto-notify mentioned users  
âœ… **Keyboard Navigation** - Full accessibility support  
âœ… **Multi-Platform Support** - Works in posts, comments, messages  
âœ… **Feed Algorithm Boost** - Mentioned posts rank higher  
âœ… **ContentEditable** - Native browser editing experience  
âœ… **Mobile Responsive** - Touch-optimized interface

### 1.3 Supported Mention Types

| Type | Icon | Badge Color | Example | Use Case |
|------|------|-------------|---------|----------|
| **ðŸ‘¤ User** | `Users` | Blue (`bg-blue-100`) | `@maria_rodriguez` | Tag dancers, friends |
| **ðŸ“… Event** | `Calendar` | Green (`bg-green-100`) | `@Friday_Milonga` | Reference tango events |
| **ðŸ‘¥ Group** | `UsersRound` | Purple (`bg-purple-100`) | `@Tango_Buenos_Aires` | Tag communities |
| **ðŸ™ï¸ City** | `MapPin` | Orange (`bg-orange-100`) | `@Buenos_Aires` | Reference locations |

### 1.4 Technology Stack

- **Frontend:** React 18 + TypeScript + ContentEditable API
- **State Management:** React Hooks (useState, useRef, useCallback)
- **Data Fetching:** React Query (TanStack Query v5)
- **Backend:** Express.js + TypeScript
- **Database:** PostgreSQL with array fields
- **Real-time:** Socket.io for notifications
- **UI Components:** shadcn/ui + Tailwind CSS
- **Icons:** lucide-react

---

## 2. System Architecture

### 2.1 High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              @Mentions System Architecture               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                â”‚                â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚ Frontend â”‚    â”‚  Backend   â”‚   â”‚Database â”‚
   â”‚Componentsâ”‚â—„â”€â”€â”€â”¤    API     â”‚â—„â”€â”€â”¤  Store  â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                â”‚
        â”‚          â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚          â”‚  Notifications â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚     System     â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Component Hierarchy

```
SimpleMentionsInput (Main Component)
â”‚
â”œâ”€â”€ ContentEditable DIV (editorRef)
â”‚   â”œâ”€â”€ Text Nodes (regular text)
â”‚   â””â”€â”€ Mention Spans (styled badges)
â”‚       â”œâ”€â”€ data-mention-type="user"
â”‚       â”œâ”€â”€ data-mention-id="user_123"
â”‚       â””â”€â”€ textContent="@maria_rodriguez"
â”‚
â”œâ”€â”€ Autocomplete Dropdown (Suggestions)
â”‚   â”œâ”€â”€ User Results
â”‚   â”œâ”€â”€ Event Results
â”‚   â”œâ”€â”€ Group Results
â”‚   â””â”€â”€ City Results
â”‚
â””â”€â”€ Token Parser (mentionTokens.ts)
    â”œâ”€â”€ parseCanonicalToTokens()
    â”œâ”€â”€ tokensToDisplay()
    â”œâ”€â”€ tokensToCanonical()
    â””â”€â”€ replaceTriggerWithMention()
```

### 2.3 Data Flow

```
User Types "@maria"
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SimpleMentionsInput             â”‚
â”‚  - Detects '@' trigger           â”‚
â”‚  - Extracts search query         â”‚
â”‚  - Shows autocomplete dropdown   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  React Query                     â”‚
â”‚  GET /api/users/search?q=maria   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Backend API                     â”‚
â”‚  - Search users matching "maria" â”‚
â”‚  - Return results with metadata  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Autocomplete Dropdown           â”‚
â”‚  - Display matching users        â”‚
â”‚  - User selects "Maria Rodriguez"â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Token System                    â”‚
â”‚  - Create mention token          â”‚
â”‚  - Insert into editor            â”‚
â”‚  - Render as styled badge        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  On Submit                       â”‚
â”‚  - Extract mention IDs           â”‚
â”‚  - Save to database              â”‚
â”‚  - Trigger notifications         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. SimpleMentionsInput Component

### 3.1 Component Overview

**File:** `client/src/components/memory/SimpleMentionsInput.tsx` (524 lines)

**Purpose:** ContentEditable-based rich text input with real-time @mention autocomplete

### 3.2 Component Props

```typescript
interface SimpleMentionsInputProps {
  value: string;                          // Current text content
  onChange: (content: string) => void;    // Content change handler
  onMentionsChange?: (mentionIds: string[]) => void; // Mention IDs extracted
  placeholder?: string;                   // Placeholder text
  className?: string;                     // Additional CSS classes
  disabled?: boolean;                     // Disable input
  rows?: number;                          // Textarea rows (height)
}
```

### 3.3 Component Usage

```tsx
import SimpleMentionsInput from '@/components/memory/SimpleMentionsInput';

function PostCreator() {
  const [content, setContent] = useState('');
  const [mentions, setMentions] = useState<string[]>([]);
  
  return (
    <SimpleMentionsInput
      value={content}
      onChange={(newContent) => {
        setContent(newContent);
      }}
      onMentionsChange={(mentionIds) => {
        setMentions(mentionIds); // ["user_123", "user_456"]
      }}
      placeholder="Share your memory and @mention people, events, or cities..."
      className="w-full border rounded-lg p-3"
      disabled={false}
      rows={6}
    />
  );
}
```

### 3.4 Internal State

```typescript
// Token state (single source of truth)
const [tokens, setTokens] = useState<Token[]>(() => parseCanonicalToTokens(value));

// Autocomplete state
const [showSuggestions, setShowSuggestions] = useState(false);
const [suggestionPosition, setSuggestionPosition] = useState({ top: 0, left: 0 });
const [currentMention, setCurrentMention] = useState(''); // Current search query
const [mentionStart, setMentionStart] = useState(0); // Cursor position of '@'
const [selectedIndex, setSelectedIndex] = useState(0); // Keyboard navigation

// Refs
const editorRef = useRef<HTMLDivElement>(null); // ContentEditable element
const lastEmittedCanonical = useRef<string>(value); // Prevent infinite loops
const isComposing = useRef(false); // IME composition detection
```

### 3.5 Core Methods

#### 3.5.1 Render Tokens to Editor

```typescript
const renderTokensToEditor = useCallback((tokensToRender: Token[]) => {
  if (!editorRef.current) return;
  
  const editor = editorRef.current;
  
  // Clear existing content
  editor.innerHTML = '';
  
  // Build DOM from tokens
  tokensToRender.forEach((token, index) => {
    if (token.kind === 'text') {
      // Regular text node
      const textNode = document.createTextNode(token.text);
      editor.appendChild(textNode);
    } else {
      // Mention badge
      const mentionSpan = document.createElement('span');
      mentionSpan.contentEditable = 'false'; // Prevent editing mention badge
      mentionSpan.setAttribute('data-mention-type', token.type);
      mentionSpan.setAttribute('data-mention-id', token.id);
      mentionSpan.className = getMentionClassName(token.type);
      mentionSpan.textContent = `@${token.name}`;
      editor.appendChild(mentionSpan);
      
      // Add space after mention if needed
      const nextToken = tokensToRender[index + 1];
      if (!nextToken || (nextToken.kind === 'text' && !nextToken.text.startsWith(' '))) {
        const space = document.createTextNode(' ');
        editor.appendChild(space);
      }
    }
  });
  
  // Handle placeholder
  if (editor.textContent?.trim() === '') {
    editor.setAttribute('data-placeholder', placeholder);
  } else {
    editor.removeAttribute('data-placeholder');
  }
}, [placeholder]);
```

#### 3.5.2 Extract Tokens from Editor

```typescript
const extractTokensFromEditor = useCallback((): Token[] => {
  if (!editorRef.current) return [];
  
  const newTokens: Token[] = [];
  
  const traverseNodes = (node: Node) => {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent || '';
      if (text) {
        // Merge consecutive text tokens
        const lastToken = newTokens[newTokens.length - 1];
        if (lastToken && lastToken.kind === 'text') {
          lastToken.text += text;
        } else {
          newTokens.push({ kind: 'text', text });
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const element = node as HTMLElement;
      
      // Handle mention spans
      if (element.hasAttribute('data-mention-type')) {
        const type = element.getAttribute('data-mention-type') as 'user' | 'event' | 'group' | 'city';
        const id = element.getAttribute('data-mention-id') || '';
        const name = element.textContent?.replace('@', '') || '';
        newTokens.push({ kind: 'mention', type, id, name });
      }
      // Handle BR tags as newlines
      else if (element.tagName === 'BR') {
        const lastToken = newTokens[newTokens.length - 1];
        if (lastToken && lastToken.kind === 'text') {
          lastToken.text += '\n';
        } else {
          newTokens.push({ kind: 'text', text: '\n' });
        }
      }
      // Recursively traverse child nodes
      else {
        Array.from(element.childNodes).forEach(traverseNodes);
      }
    }
  };
  
  Array.from(editorRef.current.childNodes).forEach(traverseNodes);
  
  return newTokens;
}, []);
```

#### 3.5.3 Handle Input Changes

```typescript
const handleInput = useCallback(() => {
  if (isComposing.current) return; // Skip during IME composition
  
  // Extract current tokens from DOM
  const currentTokens = extractTokensFromEditor();
  setTokens(currentTokens);
  
  // Convert to canonical format
  const canonical = tokensToCanonical(currentTokens);
  
  // Emit to parent only if changed
  if (canonical !== lastEmittedCanonical.current) {
    lastEmittedCanonical.current = canonical;
    onChange(canonical);
    
    // Extract mention IDs
    const mentionIds = currentTokens
      .filter((t): t is MentionToken => t.kind === 'mention')
      .map(t => t.id);
    
    onMentionsChange?.(mentionIds);
  }
  
  // Check for mention trigger
  const cursorPos = getCursorPosition();
  const displayText = tokensToDisplay(currentTokens);
  const trigger = findMentionTriggerAtCursor(displayText, cursorPos);
  
  if (trigger) {
    setCurrentMention(trigger.query);
    setMentionStart(trigger.start);
    setShowSuggestions(true);
    setSelectedIndex(0);
    updateSuggestionPosition();
  } else {
    setShowSuggestions(false);
  }
}, [onChange, onMentionsChange, extractTokensFromEditor]);
```

#### 3.5.4 Handle Mention Selection

```typescript
const handleMentionSelect = useCallback((mention: MentionData) => {
  const currentTokens = extractTokensFromEditor();
  const displayText = tokensToDisplay(currentTokens);
  const cursorPos = getCursorPosition();
  
  // Create new mention token
  const newMention: MentionToken = {
    kind: 'mention',
    type: mention.type,
    id: mention.id,
    name: mention.display
  };
  
  // Replace trigger text with mention
  const newTokens = replaceTriggerWithMention(
    currentTokens,
    displayText,
    cursorPos,
    newMention
  );
  
  // Update state
  setTokens(newTokens);
  renderTokensToEditor(newTokens);
  
  // Emit changes
  const canonical = tokensToCanonical(newTokens);
  lastEmittedCanonical.current = canonical;
  onChange(canonical);
  
  const mentionIds = newTokens
    .filter((t): t is MentionToken => t.kind === 'mention')
    .map(t => t.id);
  onMentionsChange?.(mentionIds);
  
  // Close dropdown
  setShowSuggestions(false);
  
  // Restore focus
  editorRef.current?.focus();
}, [onChange, onMentionsChange, extractTokensFromEditor, renderTokensToEditor]);
```

### 3.6 Event Handlers

```typescript
// Keyboard navigation
const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
  if (!showSuggestions) return;
  
  switch (e.key) {
    case 'ArrowDown':
      e.preventDefault();
      setSelectedIndex((prev) => 
        prev < suggestions.length - 1 ? prev + 1 : prev
      );
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      setSelectedIndex((prev) => prev > 0 ? prev - 1 : 0);
      break;
      
    case 'Enter':
      e.preventDefault();
      if (suggestions[selectedIndex]) {
        handleMentionSelect(suggestions[selectedIndex]);
      }
      break;
      
    case 'Escape':
      e.preventDefault();
      setShowSuggestions(false);
      break;
  }
}, [showSuggestions, selectedIndex, suggestions, handleMentionSelect]);

// IME composition
const handleCompositionStart = () => {
  isComposing.current = true;
};

const handleCompositionEnd = () => {
  isComposing.current = false;
  handleInput(); // Process accumulated input
};

// Paste handling
const handlePaste = useCallback((e: React.ClipboardEvent) => {
  e.preventDefault();
  
  // Get plain text from clipboard
  const text = e.clipboardData.getData('text/plain');
  
  // Insert as plain text (no formatting)
  document.execCommand('insertText', false, text);
}, []);
```

---

## 4. Token System & Parsing

### 4.1 Token Types

**File:** `client/src/utils/mentionTokens.ts`

```typescript
// Base token interface
export type Token = TextToken | MentionToken;

// Text token (regular content)
export interface TextToken {
  kind: 'text';
  text: string;
}

// Mention token (tagged entity)
export interface MentionToken {
  kind: 'mention';
  type: 'user' | 'event' | 'group' | 'city';
  id: string;    // Entity ID (e.g., "user_123")
  name: string;  // Display name (e.g., "maria_rodriguez")
}
```

### 4.2 Canonical Format

**Canonical format** is the string representation stored in the database:

```typescript
// Example canonical string
"Had a great time with @user:user_123:maria_rodriguez at @event:evt_456:Friday_Milonga!"

// Format: @{type}:{id}:{name}
```

### 4.3 Parsing Functions

#### 4.3.1 Parse Canonical to Tokens

```typescript
export function parseCanonicalToTokens(canonical: string): Token[] {
  const tokens: Token[] = [];
  const regex = /@(user|event|group|city):([^:]+):([^\s]+)/g;
  let lastIndex = 0;
  let match: RegExpExecArray | null;
  
  while ((match = regex.exec(canonical)) !== null) {
    // Add text before mention
    if (match.index > lastIndex) {
      const text = canonical.substring(lastIndex, match.index);
      tokens.push({ kind: 'text', text });
    }
    
    // Add mention token
    const [, type, id, name] = match;
    tokens.push({
      kind: 'mention',
      type: type as 'user' | 'event' | 'group' | 'city',
      id,
      name
    });
    
    lastIndex = regex.lastIndex;
  }
  
  // Add remaining text
  if (lastIndex < canonical.length) {
    const text = canonical.substring(lastIndex);
    tokens.push({ kind: 'text', text });
  }
  
  return tokens;
}
```

#### 4.3.2 Tokens to Canonical

```typescript
export function tokensToCanonical(tokens: Token[]): string {
  return tokens.map(token => {
    if (token.kind === 'text') {
      return token.text;
    } else {
      return `@${token.type}:${token.id}:${token.name}`;
    }
  }).join('');
}
```

#### 4.3.3 Tokens to Display

```typescript
export function tokensToDisplay(tokens: Token[]): string {
  return tokens.map(token => {
    if (token.kind === 'text') {
      return token.text;
    } else {
      return `@${token.name}`;
    }
  }).join('');
}
```

#### 4.3.4 Find Mention Trigger

```typescript
export function findMentionTriggerAtCursor(
  text: string,
  cursorPos: number
): { start: number; query: string } | null {
  // Find the last '@' before cursor
  let atPos = -1;
  for (let i = cursorPos - 1; i >= 0; i--) {
    if (text[i] === '@') {
      atPos = i;
      break;
    }
    // Stop at whitespace
    if (/\s/.test(text[i])) {
      break;
    }
  }
  
  if (atPos === -1) return null;
  
  // Extract query between '@' and cursor
  const query = text.substring(atPos + 1, cursorPos);
  
  // Must not contain whitespace
  if (/\s/.test(query)) return null;
  
  return { start: atPos, query };
}
```

#### 4.3.5 Replace Trigger with Mention

```typescript
export function replaceTriggerWithMention(
  tokens: Token[],
  displayText: string,
  cursorPos: number,
  mention: MentionToken
): Token[] {
  const trigger = findMentionTriggerAtCursor(displayText, cursorPos);
  if (!trigger) return tokens;
  
  const newTokens: Token[] = [];
  let charCount = 0;
  
  for (const token of tokens) {
    if (token.kind === 'text') {
      const tokenStart = charCount;
      const tokenEnd = charCount + token.text.length;
      
      // Check if trigger overlaps with this text token
      if (tokenStart <= trigger.start && tokenEnd >= cursorPos) {
        // Split text token around trigger
        const before = token.text.substring(0, trigger.start - tokenStart);
        const after = token.text.substring(cursorPos - tokenStart);
        
        if (before) {
          newTokens.push({ kind: 'text', text: before });
        }
        newTokens.push(mention);
        if (after) {
          newTokens.push({ kind: 'text', text: after });
        }
      } else {
        newTokens.push(token);
      }
      
      charCount += token.text.length;
    } else {
      newTokens.push(token);
      charCount += token.name.length + 1; // +1 for '@'
    }
  }
  
  return newTokens;
}
```

### 4.4 Example Transformation

```typescript
// Step 1: User types
Input: "Dancing with @maria"

// Step 2: Parsed to tokens
Tokens: [
  { kind: 'text', text: 'Dancing with ' },
  { kind: 'text', text: '@maria' }
]

// Step 3: User selects "Maria Rodriguez" from dropdown
Selected: { type: 'user', id: 'user_123', name: 'maria_rodriguez' }

// Step 4: Replace trigger with mention
New Tokens: [
  { kind: 'text', text: 'Dancing with ' },
  { kind: 'mention', type: 'user', id: 'user_123', name: 'maria_rodriguez' }
]

// Step 5: Convert to canonical (for database)
Canonical: "Dancing with @user:user_123:maria_rodriguez"

// Step 6: Convert to display (for UI)
Display: "Dancing with @maria_rodriguez"

// Step 7: Render to DOM
<div contentEditable>
  Dancing with 
  <span 
    data-mention-type="user" 
    data-mention-id="user_123"
    class="bg-blue-100 text-blue-700"
  >
    @maria_rodriguez
  </span>
</div>
```

---

## 5. Database Schema

### 5.1 Posts Table

```typescript
// File: shared/schema.ts
export const posts = pgTable("posts", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content"), // Display text: "Dancing with @maria_rodriguez"
  
  // Mentions array (stores user IDs)
  mentions: text("mentions").array().default([]),
  // Example: ["user_123", "user_456", "user_789"]
  
  // Rich content (optional, for HTML rendering)
  richContent: text("rich_content"),
  // Example: "Dancing with <strong>@maria_rodriguez</strong>"
  
  visibility: varchar("visibility", { length: 20 }).default("everyone"),
  tags: text("tags").array().default([]),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
}, (table) => [
  index("idx_posts_user").on(table.userId),
  index("idx_posts_mentions").on(table.mentions), // For querying mentioned posts
  index("idx_posts_created").on(table.createdAt),
]);
```

### 5.2 Comments Table

```typescript
export const postComments = pgTable("post_comments", {
  id: serial("id").primaryKey(),
  postId: integer("post_id").references(() => posts.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  
  // Mentions in comments
  mentions: text("mentions").array().default([]),
  
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("idx_comments_post").on(table.postId),
  index("idx_comments_mentions").on(table.mentions),
]);
```

### 5.3 Notifications Table

```typescript
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  
  type: varchar("type", { length: 50 }).notNull(),
  // mention, comment, like, follow, etc.
  
  title: varchar("title", { length: 255 }).notNull(),
  message: text("message").notNull(),
  
  data: jsonb("data").default({}),
  // { postId, mentionerId, mentionerName, postExcerpt, ... }
  
  isRead: boolean("is_read").default(false),
  actionUrl: text("action_url"),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => [
  index("idx_notifications_user").on(table.userId),
  index("idx_notifications_unread").on(table.userId, table.isRead),
  index("idx_notifications_type").on(table.type),
]);
```

### 5.4 Data Examples

#### Post with Mentions
```json
{
  "id": 123,
  "userId": 1,
  "content": "Had a great time with @maria_rodriguez at @Friday_Milonga in @Buenos_Aires!",
  "mentions": [
    "user_123",      // Maria Rodriguez
    "event_456",     // Friday Milonga
    "city_789"       // Buenos Aires
  ],
  "richContent": "Had a great time with <strong>@maria_rodriguez</strong> at <strong>@Friday_Milonga</strong> in <strong>@Buenos_Aires</strong>!",
  "visibility": "friends",
  "tags": ["tango", "milonga", "social"],
  "createdAt": "2025-01-09T20:00:00Z"
}
```

#### Mention Notification
```json
{
  "id": 456,
  "userId": 123, // Maria's ID (she was mentioned)
  "type": "mention",
  "title": "You were mentioned",
  "message": "Pierre mentioned you in a post: 'Had a great time with @maria...'",
  "data": {
    "postId": 123,
    "mentionerId": 1,
    "mentionerName": "Pierre Dancer",
    "mentionerAvatar": "https://...",
    "postExcerpt": "Had a great time with @maria_rodriguez..."
  },
  "actionUrl": "/memories?post=123",
  "isRead": false,
  "createdAt": "2025-01-09T20:00:01Z"
}
```

---

## 6. Backend API Endpoints

### 6.1 Search Users for Mentions

**Endpoint:** `GET /api/users/search?q={query}`

**Purpose:** Real-time user search for @mention autocomplete

**Query Parameters:**
- `q` (string, required) - Search query (min 1 character)

**Response:**
```typescript
{
  "data": [
    {
      "id": "user_123",
      "username": "maria_rodriguez",
      "name": "Maria Rodriguez",
      "profileImage": "https://...",
      "type": "user",
      "status": "online" // Optional
    },
    {
      "id": "user_456",
      "username": "maria_garcia",
      "name": "Maria Garcia",
      "profileImage": "https://...",
      "type": "user",
      "status": "offline"
    }
  ]
}
```

**Implementation:**
```typescript
// File: server/routes.ts
app.get('/api/users/search', async (req, res) => {
  const { q } = req.query;
  
  if (!q || typeof q !== 'string' || q.length < 1) {
    return res.json({ data: [] });
  }
  
  try {
    // Search users by name or username
    const users = await db
      .select({
        id: users.id,
        username: users.username,
        name: users.name,
        profileImage: users.profileImage,
        type: sql<string>`'user'`,
        status: users.status
      })
      .from(users)
      .where(
        or(
          ilike(users.name, `%${q}%`),
          ilike(users.username, `%${q}%`)
        )
      )
      .limit(10)
      .orderBy(desc(users.lastActive));
    
    res.json({ data: users });
  } catch (error) {
    console.error('User search error:', error);
    res.status(500).json({ error: 'Search failed' });
  }
});
```

### 6.2 Search Events for Mentions

**Endpoint:** `GET /api/events/search?q={query}`

**Response:**
```typescript
{
  "data": [
    {
      "id": "event_456",
      "title": "Friday Night Milonga",
      "slug": "friday-night-milonga",
      "type": "event",
      "eventType": "milonga",
      "startDate": "2025-01-10T23:00:00Z",
      "venue": "La Viruta"
    }
  ]
}
```

### 6.3 Search Groups for Mentions

**Endpoint:** `GET /api/groups/search?q={query}`

**Response:**
```typescript
{
  "data": [
    {
      "id": "group_789",
      "name": "Tango Buenos Aires",
      "slug": "tango-buenos-aires",
      "type": "group",
      "groupType": "city",
      "memberCount": 1234,
      "imageUrl": "https://..."
    }
  ]
}
```

### 6.4 Search Cities for Mentions

**Endpoint:** `GET /api/cities/search?q={query}`

**Response:**
```typescript
{
  "data": [
    {
      "id": "city_101",
      "name": "Buenos Aires",
      "country": "Argentina",
      "type": "city",
      "coordinates": { lat: -34.6037, lng: -58.3816 }
    }
  ]
}
```

### 6.5 Create Post with Mentions

**Endpoint:** `POST /api/posts`

**Request:**
```typescript
{
  "content": "Had a great time with @maria_rodriguez!",
  "mentions": ["user_123"],
  "visibility": "friends",
  "tags": ["tango"]
}
```

**Backend Processing:**
```typescript
app.post('/api/posts', async (req, res) => {
  const { content, mentions = [], visibility, tags } = req.body;
  const userId = req.user.id;
  
  // 1. Create post
  const post = await db.insert(posts).values({
    userId,
    content,
    mentions,
    visibility,
    tags
  }).returning();
  
  // 2. Send notifications to mentioned users
  if (mentions.length > 0) {
    await Promise.all(
      mentions
        .filter(id => id.startsWith('user_')) // Only notify users
        .map(async (mentionedUserId) => {
          const mentionedId = parseInt(mentionedUserId.replace('user_', ''));
          
          // Create notification
          await db.insert(notifications).values({
            userId: mentionedId,
            type: 'mention',
            title: 'You were mentioned',
            message: `${req.user.name} mentioned you in a post`,
            data: {
              postId: post[0].id,
              mentionerId: userId,
              mentionerName: req.user.name,
              mentionerAvatar: req.user.profileImage,
              postExcerpt: content.substring(0, 100)
            },
            actionUrl: `/memories?post=${post[0].id}`
          });
          
          // Send real-time notification via Socket.io
          io.to(`user:${mentionedId}`).emit('notification:new', {
            type: 'mention',
            postId: post[0].id,
            mentioner: req.user.name
          });
        })
    );
  }
  
  // 3. Broadcast new post
  io.emit('post:new', post[0]);
  
  res.json({ success: true, post: post[0] });
});
```

### 6.6 Get Posts Where User is Mentioned

**Endpoint:** `GET /api/users/:userId/mentions`

**Purpose:** Get all posts where user was mentioned

**Response:**
```typescript
{
  "posts": [
    {
      "id": 123,
      "content": "...",
      "mentions": ["user_123"],
      "user": { ... },
      "createdAt": "..."
    }
  ]
}
```

**Query:**
```typescript
app.get('/api/users/:userId/mentions', async (req, res) => {
  const { userId } = req.params;
  
  const mentionedPosts = await db
    .select()
    .from(posts)
    .where(sql`${userId} = ANY(${posts.mentions})`)
    .orderBy(desc(posts.createdAt))
    .limit(50);
  
  res.json({ posts: mentionedPosts });
});
```

---

## 7. User Interaction Flows

### 7.1 Flow: Create Post with User Mention

```
Step 1: User navigates to Memory Feed
        â†“
Step 2: Clicks in SimpleMentionsInput textarea
        â†“
Step 3: Types: "Dancing with "
        â†“
Step 4: Types: "@"
        â”œâ”€ Autocomplete dropdown appears
        â”œâ”€ Position calculated based on cursor
        â””â”€ Empty state: "Type to search users..."
        â†“
Step 5: Types: "m"
        â”œâ”€ Query updates: currentMention = "m"
        â”œâ”€ API call: GET /api/users/search?q=m
        â””â”€ Dropdown shows: Maria Rodriguez, Maria Garcia, etc.
        â†“
Step 6: Types: "ar"
        â”œâ”€ Query updates: currentMention = "mar"
        â”œâ”€ API call: GET /api/users/search?q=mar
        â””â”€ Results refined: Maria Rodriguez, Maria Garcia
        â†“
Step 7: User navigates dropdown:
        â”œâ”€ Arrow Down: selectedIndex = 1
        â”œâ”€ Arrow Up: selectedIndex = 0
        â””â”€ Current: Maria Rodriguez (highlighted)
        â†“
Step 8: User presses Enter (or clicks)
        â”œâ”€ handleMentionSelect() called
        â”œâ”€ Create mention token: { kind: 'mention', type: 'user', id: 'user_123', name: 'maria_rodriguez' }
        â”œâ”€ Replace "@mar" with mention badge
        â”œâ”€ Render to DOM: <span>@maria_rodriguez</span>
        â”œâ”€ Update mentions array: ["user_123"]
        â””â”€ Close dropdown
        â†“
Step 9: User continues typing: " at the milonga!"
        â†“
Step 10: User clicks "Share Memory" button
        â†“
Step 11: POST /api/posts
        â”œâ”€ content: "Dancing with @maria_rodriguez at the milonga!"
        â”œâ”€ mentions: ["user_123"]
        â””â”€ visibility: "friends"
        â†“
Step 12: Backend processing:
        â”œâ”€ Create post in database
        â”œâ”€ Create notification for Maria (user_123)
        â”œâ”€ Send Socket.io event to Maria
        â””â”€ Broadcast new post to feed
        â†“
Step 13: Maria receives notification:
        â”œâ”€ Bell icon shows badge "1"
        â”œâ”€ Toast: "Pierre mentioned you in a post"
        â””â”€ Click â†’ Navigate to post
```

### 7.2 Flow: Multiple Entity Mentions

```
User Input: "@maria from @Buenos_Aires will perform at @Friday_Milonga"
             â†‘        â†‘                              â†‘
           User    City                         Event

Step 1: Type "@maria"
  â†’ Select: Maria Rodriguez (user_123)
  â†’ Insert: @user:user_123:maria_rodriguez

Step 2: Type " from @Buenos"
  â†’ API: GET /api/cities/search?q=Buenos
  â†’ Results: Buenos Aires, Argentina
  â†’ Select: Buenos Aires (city_789)
  â†’ Insert: @city:city_789:Buenos_Aires

Step 3: Type " will perform at @Friday"
  â†’ API: GET /api/events/search?q=Friday
  â†’ Results: Friday Night Milonga, Friday Practica
  â†’ Select: Friday Night Milonga (event_456)
  â†’ Insert: @event:event_456:Friday_Milonga

Final State:
  Tokens: [
    { kind: 'text', text: '' },
    { kind: 'mention', type: 'user', id: 'user_123', name: 'maria_rodriguez' },
    { kind: 'text', text: ' from ' },
    { kind: 'mention', type: 'city', id: 'city_789', name: 'Buenos_Aires' },
    { kind: 'text', text: ' will perform at ' },
    { kind: 'mention', type: 'event', id: 'event_456', name: 'Friday_Milonga' }
  ]
  
  Canonical: "@user:user_123:maria_rodriguez from @city:city_789:Buenos_Aires will perform at @event:event_456:Friday_Milonga"
  
  Display: "@maria_rodriguez from @Buenos_Aires will perform at @Friday_Milonga"
  
  Mentions Array: ["user_123", "city_789", "event_456"]
  
  Notifications Sent:
    âœ… user_123 (Maria) - "You were mentioned in a post"
    âŒ city_789 - No notification (cities don't get notified)
    âŒ event_456 - No notification (events don't get notified)
```

### 7.3 Flow: Keyboard Navigation

```
Dropdown visible with 5 results:

Index 0: [Maria Rodriguez]  â† selectedIndex = 0 (highlighted)
Index 1: Maria Garcia
Index 2: Maria Fernandez
Index 3: Mario Lopez
Index 4: Mariela Santos

User Actions:
  â†“ Arrow Down
    â†’ selectedIndex = 1
    â†’ Highlight: Maria Garcia

  â†“ Arrow Down
    â†’ selectedIndex = 2
    â†’ Highlight: Maria Fernandez

  â†‘ Arrow Up
    â†’ selectedIndex = 1
    â†’ Highlight: Maria Garcia

  Enter
    â†’ handleMentionSelect(users[1])
    â†’ Insert: Maria Garcia
    â†’ Close dropdown

  Escape
    â†’ setShowSuggestions(false)
    â†’ Close dropdown without selection
```

### 7.4 Flow: Edit Post with Existing Mentions

```
Existing Post:
  content: "Dancing with @maria_rodriguez"
  mentions: ["user_123"]

Step 1: User clicks "Edit" button
        â†“
Step 2: PostCreator opens in edit mode
        â”œâ”€ value prop = canonical format
        â”œâ”€ Parse: parseCanonicalToTokens()
        â””â”€ Render: Show "@maria_rodriguez" as blue badge
        â†“
Step 3: User edits: "Dancing with @maria_rodriguez and @carlos"
        â”œâ”€ Existing mention preserved
        â”œâ”€ New mention added
        â””â”€ mentions array: ["user_123", "user_456"]
        â†“
Step 4: User saves
        â”œâ”€ PATCH /api/posts/:id
        â”œâ”€ Update content + mentions
        â””â”€ Send notification to Carlos (new mention)
```

---

## 8. Notifications Integration

### 8.1 Mention Notification Structure

```typescript
interface MentionNotification {
  id: number;
  userId: number; // User who was mentioned
  type: 'mention';
  title: 'You were mentioned';
  message: string; // "{mentionerName} mentioned you in a post"
  data: {
    postId: number;
    mentionerId: number;
    mentionerName: string;
    mentionerAvatar: string;
    postExcerpt: string; // First 100 chars of post
    mentionType: 'post' | 'comment'; // Where they were mentioned
  };
  actionUrl: string; // Link to post/comment
  isRead: boolean;
  createdAt: string;
}
```

### 8.2 Notification Creation Flow

```typescript
// When post is created with mentions
async function createPostWithMentions(postData, mentionedUserIds) {
  // 1. Create post
  const post = await db.insert(posts).values(postData).returning();
  
  // 2. Filter for user mentions only
  const userMentions = mentionedUserIds.filter(id => id.startsWith('user_'));
  
  // 3. Create notifications for each mentioned user
  for (const mentionId of userMentions) {
    const userId = parseInt(mentionId.replace('user_', ''));
    
    // Don't notify yourself
    if (userId === postData.userId) continue;
    
    // Create notification
    await db.insert(notifications).values({
      userId,
      type: 'mention',
      title: 'You were mentioned',
      message: `${postData.userName} mentioned you in a post`,
      data: {
        postId: post[0].id,
        mentionerId: postData.userId,
        mentionerName: postData.userName,
        mentionerAvatar: postData.userAvatar,
        postExcerpt: postData.content.substring(0, 100),
        mentionType: 'post'
      },
      actionUrl: `/memories?post=${post[0].id}`
    });
    
    // 4. Send real-time notification via Socket.io
    io.to(`user:${userId}`).emit('notification:new', {
      type: 'mention',
      postId: post[0].id,
      mentioner: postData.userName
    });
    
    // 5. Optional: Send email notification
    if (userPreferences[userId]?.emailOnMention) {
      await sendEmailNotification(userId, 'mention', {
        mentionerName: postData.userName,
        postUrl: `${BASE_URL}/memories?post=${post[0].id}`
      });
    }
  }
  
  return post[0];
}
```

### 8.3 Real-Time Notification Display

```tsx
// Client-side notification listener
useEffect(() => {
  if (!socket) return;
  
  socket.on('notification:new', (data) => {
    if (data.type === 'mention') {
      // Show toast notification
      toast({
        title: 'You were mentioned!',
        description: `${data.mentioner} mentioned you in a post`,
        action: (
          <Button
            size="sm"
            onClick={() => navigate(`/memories?post=${data.postId}`)}
          >
            View
          </Button>
        )
      });
      
      // Update notification badge count
      queryClient.invalidateQueries({ queryKey: ['/api/notifications/unread-count'] });
      
      // Play notification sound (optional)
      playNotificationSound();
    }
  });
  
  return () => {
    socket.off('notification:new');
  };
}, [socket]);
```

---

## 9. Visual Styling & Theming

### 9.1 Mention Badge Styles

```css
/* Base mention badge */
.mention-badge {
  display: inline-flex;
  align-items: center;
  padding: 0.125rem 0.5rem;
  border-radius: 0.375rem;
  font-weight: 600;
  font-size: 0.875rem;
  margin: 0 0.125rem;
  cursor: pointer;
  transition: all 0.2s;
  user-select: none;
}

.mention-badge:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* User mention - Blue */
.mention-user {
  background-color: rgb(219 234 254); /* blue-100 */
  color: rgb(29 78 216); /* blue-700 */
}

.mention-user:hover {
  background-color: rgb(191 219 254); /* blue-200 */
}

/* Event mention - Green */
.mention-event {
  background-color: rgb(220 252 231); /* green-100 */
  color: rgb(21 128 61); /* green-700 */
}

/* Group mention - Purple */
.mention-group {
  background-color: rgb(243 232 255); /* purple-100 */
  color: rgb(107 33 168); /* purple-700 */
}

/* City mention - Orange */
.mention-city {
  background-color: rgb(255 237 213); /* orange-100 */
  color: rgb(194 65 12); /* orange-700 */
}
```

### 9.2 ContentEditable Styling

```css
/* SimpleMentionsInput container */
.mentions-input-container {
  position: relative;
  width: 100%;
}

/* ContentEditable editor */
.mentions-editor {
  min-height: 120px;
  padding: 0.75rem;
  border: 2px solid rgb(229 231 235); /* gray-200 */
  border-radius: 0.5rem;
  font-size: 1rem;
  line-height: 1.5;
  outline: none;
  transition: border-color 0.2s;
}

.mentions-editor:focus {
  border-color: rgb(59 130 246); /* blue-500 */
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}

/* Placeholder */
.mentions-editor[data-placeholder]:empty::before {
  content: attr(data-placeholder);
  color: rgb(156 163 175); /* gray-400 */
  pointer-events: none;
}

/* Disabled state */
.mentions-editor:disabled {
  background-color: rgb(249 250 251); /* gray-50 */
  cursor: not-allowed;
  opacity: 0.6;
}
```

### 9.3 Autocomplete Dropdown Styling

```css
/* Dropdown container */
.mentions-dropdown {
  position: absolute;
  z-index: 50;
  margin-top: 0.5rem;
  width: 20rem;
  max-height: 20rem;
  overflow-y: auto;
  background: white;
  border-radius: 0.75rem;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
  border: 1px solid rgb(229 231 235);
}

/* Dropdown item */
.mentions-dropdown-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  padding: 0.75rem;
  cursor: pointer;
  transition: background-color 0.15s;
}

.mentions-dropdown-item:hover {
  background-color: rgb(249 250 251); /* gray-50 */
}

.mentions-dropdown-item.selected {
  background-color: rgb(239 246 255); /* blue-50 */
}

/* Avatar */
.mentions-dropdown-avatar {
  width: 2.5rem;
  height: 2.5rem;
  border-radius: 9999px;
  object-fit: cover;
}

/* User info */
.mentions-dropdown-info {
  flex: 1;
}

.mentions-dropdown-name {
  font-weight: 600;
  font-size: 0.875rem;
  color: rgb(17 24 39); /* gray-900 */
}

.mentions-dropdown-username {
  font-size: 0.75rem;
  color: rgb(107 114 128); /* gray-500 */
}

/* Type badge */
.mentions-dropdown-badge {
  padding: 0.25rem 0.5rem;
  border-radius: 0.375rem;
  font-size: 0.75rem;
  font-weight: 500;
  background-color: rgb(243 244 246); /* gray-100 */
  color: rgb(75 85 99); /* gray-600 */
}
```

### 9.4 Dark Mode Support

```css
/* Dark mode styles */
@media (prefers-color-scheme: dark) {
  .mentions-editor {
    background-color: rgb(31 41 55); /* gray-800 */
    border-color: rgb(55 65 81); /* gray-700 */
    color: rgb(243 244 246); /* gray-100 */
  }
  
  .mentions-editor:focus {
    border-color: rgb(96 165 250); /* blue-400 */
  }
  
  .mention-user {
    background-color: rgb(30 58 138); /* blue-900 */
    color: rgb(191 219 254); /* blue-200 */
  }
  
  .mentions-dropdown {
    background-color: rgb(31 41 55); /* gray-800 */
    border-color: rgb(55 65 81); /* gray-700 */
  }
  
  .mentions-dropdown-item:hover {
    background-color: rgb(55 65 81); /* gray-700 */
  }
  
  .mentions-dropdown-item.selected {
    background-color: rgb(30 58 138); /* blue-900 */
  }
}
```

---

## 10. Multi-Entity Support

### 10.1 Entity Type Definitions

```typescript
type EntityType = 'user' | 'event' | 'group' | 'city';

interface EntitySearchResult {
  id: string;
  type: EntityType;
  display: string;
  avatar?: string;
  subtitle?: string;
  metadata?: Record<string, any>;
}
```

### 10.2 Unified Search Function

```typescript
async function searchAllEntities(query: string): Promise<EntitySearchResult[]> {
  const results: EntitySearchResult[] = [];
  
  // Search users
  const users = await searchUsers(query);
  results.push(...users.map(u => ({
    id: `user_${u.id}`,
    type: 'user' as EntityType,
    display: u.username,
    avatar: u.profileImage,
    subtitle: u.name,
    metadata: { status: u.status }
  })));
  
  // Search events
  const events = await searchEvents(query);
  results.push(...events.map(e => ({
    id: `event_${e.id}`,
    type: 'event' as EntityType,
    display: e.title,
    avatar: e.imageUrl,
    subtitle: `${e.eventType} â€¢ ${formatDate(e.startDate)}`,
    metadata: { venue: e.venue }
  })));
  
  // Search groups
  const groups = await searchGroups(query);
  results.push(...groups.map(g => ({
    id: `group_${g.id}`,
    type: 'group' as EntityType,
    display: g.name,
    avatar: g.imageUrl,
    subtitle: `${g.memberCount} members`,
    metadata: { groupType: g.type }
  })));
  
  // Search cities
  const cities = await searchCities(query);
  results.push(...cities.map(c => ({
    id: `city_${c.id}`,
    type: 'city' as EntityType,
    display: c.name,
    subtitle: c.country,
    metadata: { coordinates: c.coordinates }
  })));
  
  return results;
}
```

### 10.3 Entity-Specific Icons

```tsx
function getEntityIcon(type: EntityType) {
  switch (type) {
    case 'user':
      return <Users className="w-4 h-4" />;
    case 'event':
      return <Calendar className="w-4 h-4" />;
    case 'group':
      return <UsersRound className="w-4 h-4" />;
    case 'city':
      return <MapPin className="w-4 h-4" />;
  }
}
```

### 10.4 Entity-Specific Rendering

```tsx
function renderEntityDropdownItem(entity: EntitySearchResult, isSelected: boolean) {
  return (
    <div className={`mentions-dropdown-item ${isSelected ? 'selected' : ''}`}>
      {/* Avatar or Icon */}
      {entity.avatar ? (
        <img src={entity.avatar} className="mentions-dropdown-avatar" />
      ) : (
        <div className="mentions-dropdown-avatar bg-gray-200 flex items-center justify-center">
          {getEntityIcon(entity.type)}
        </div>
      )}
      
      {/* Info */}
      <div className="mentions-dropdown-info">
        <div className="mentions-dropdown-name">{entity.display}</div>
        {entity.subtitle && (
          <div className="mentions-dropdown-username">{entity.subtitle}</div>
        )}
      </div>
      
      {/* Type Badge */}
      <Badge variant="secondary" className="mentions-dropdown-badge">
        {getEntityIcon(entity.type)}
        <span className="ml-1 capitalize">{entity.type}</span>
      </Badge>
    </div>
  );
}
```

---

## 11. Autocomplete Dropdown

### 11.1 Dropdown Component

```tsx
interface DropdownProps {
  suggestions: EntitySearchResult[];
  selectedIndex: number;
  position: { top: number; left: number };
  onSelect: (entity: EntitySearchResult) => void;
}

function MentionsDropdown({ 
  suggestions, 
  selectedIndex, 
  position, 
  onSelect 
}: DropdownProps) {
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  // Scroll selected item into view
  useEffect(() => {
    if (dropdownRef.current) {
      const selectedItem = dropdownRef.current.children[selectedIndex] as HTMLElement;
      selectedItem?.scrollIntoView({ block: 'nearest' });
    }
  }, [selectedIndex]);
  
  if (suggestions.length === 0) {
    return (
      <Card 
        className="absolute z-50 w-80 shadow-xl"
        style={{ top: position.top, left: position.left }}
      >
        <CardContent className="p-4 text-center text-gray-500">
          <Users className="w-8 h-8 mx-auto mb-2 opacity-50" />
          <p className="text-sm">No results found</p>
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card 
      ref={dropdownRef}
      className="absolute z-50 w-80 max-h-80 overflow-y-auto shadow-xl"
      style={{ top: position.top, left: position.left }}
    >
      <CardContent className="p-0">
        {suggestions.map((entity, index) => (
          <div
            key={entity.id}
            className={`flex items-center gap-3 p-3 cursor-pointer transition-colors ${
              index === selectedIndex 
                ? 'bg-blue-50 dark:bg-blue-900' 
                : 'hover:bg-gray-50 dark:hover:bg-gray-700'
            }`}
            onClick={() => onSelect(entity)}
            onMouseEnter={() => setHoveredIndex(index)}
          >
            {/* Avatar */}
            <Avatar className="w-10 h-10">
              {entity.avatar ? (
                <AvatarImage src={entity.avatar} />
              ) : (
                <AvatarFallback>
                  {getEntityIcon(entity.type)}
                </AvatarFallback>
              )}
            </Avatar>
            
            {/* Info */}
            <div className="flex-1 min-w-0">
              <div className="font-semibold text-sm truncate">
                {entity.display}
              </div>
              {entity.subtitle && (
                <div className="text-xs text-gray-500 truncate">
                  {entity.subtitle}
                </div>
              )}
            </div>
            
            {/* Badge */}
            <Badge variant="secondary" className="text-xs shrink-0">
              {getEntityIcon(entity.type)}
              <span className="ml-1 capitalize">{entity.type}</span>
            </Badge>
          </div>
        ))}
      </CardContent>
    </Card>
  );
}
```

### 11.2 Position Calculation

```typescript
function updateSuggestionPosition() {
  if (!editorRef.current) return;
  
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0) return;
  
  const range = selection.getRangeAt(0);
  const rect = range.getBoundingClientRect();
  const editorRect = editorRef.current.getBoundingClientRect();
  
  // Position dropdown below cursor
  setSuggestionPosition({
    top: rect.bottom - editorRect.top + 4,
    left: rect.left - editorRect.left
  });
}
```

---

## 12. Feed Algorithm Integration

### 12.1 Social Score Calculation

Mentions boost post visibility in feed algorithms:

```typescript
function calculateSocialScore(post: Post): number {
  let score = 0;
  
  // Mentions: +3 points per mention (max 10)
  const mentionPoints = Math.min(post.mentions.length * 3, 10);
  score += mentionPoints;
  
  // Likes: +1 point per like (max 15)
  score += Math.min(post.likeCount, 15);
  
  // Comments: +2 points per comment (max 10)
  score += Math.min(post.commentCount * 2, 10);
  
  // Friendship closeness
  const closeness = getFriendshipCloseness(currentUserId, post.userId);
  if (closeness >= 0.8) score += 15; // Close friends
  else if (closeness >= 0.6) score += 10; // Good friends
  else if (closeness >= 0.4) score += 5; // Regular friends
  
  return score;
}
```

### 12.2 Feed Ranking

```typescript
async function getRankedFeed(userId: number, filters: FeedFilters) {
  const posts = await db
    .select()
    .from(posts)
    .where(/* visibility filters */)
    .orderBy(desc(posts.createdAt))
    .limit(100);
  
  // Calculate scores
  const scoredPosts = posts.map(post => ({
    ...post,
    socialScore: calculateSocialScore(post),
    timeScore: calculateTimeScore(post),
    emotionalScore: calculateEmotionalScore(post),
    contentScore: calculateContentScore(post)
  }));
  
  // Rank by total score
  scoredPosts.sort((a, b) => {
    const scoreA = a.socialScore + a.timeScore + a.emotionalScore + a.contentScore;
    const scoreB = b.socialScore + b.timeScore + b.emotionalScore + b.contentScore;
    return scoreB - scoreA;
  });
  
  return scoredPosts;
}
```

---

## 13. Performance & Optimization

### 13.1 Debounced Search

```typescript
import { useDebounce } from '@/hooks/useDebounce';

const debouncedQuery = useDebounce(currentMention, 300);

const { data: suggestions = [] } = useQuery({
  queryKey: ['/api/users/search', debouncedQuery],
  queryFn: async () => {
    if (!debouncedQuery || debouncedQuery.length < 1) return [];
    const response = await fetch(`/api/users/search?q=${encodeURIComponent(debouncedQuery)}`);
    return response.json();
  },
  enabled: showSuggestions && debouncedQuery.length > 0,
  staleTime: 30 * 1000 // Cache for 30 seconds
});
```

### 13.2 React Query Caching

```typescript
// Cache user search results
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 30 * 1000, // 30 seconds
      cacheTime: 5 * 60 * 1000, // 5 minutes
      refetchOnWindowFocus: false
    }
  }
});

// Prefetch on hover
const prefetchUser = async (userId: string) => {
  await queryClient.prefetchQuery({
    queryKey: ['/api/users', userId],
    queryFn: () => fetchUser(userId)
  });
};
```

### 13.3 Virtual Scrolling (Large Result Sets)

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

function LargeMentionsDropdown({ suggestions }) {
  const parentRef = useRef<HTMLDivElement>(null);
  
  const rowVirtualizer = useVirtualizer({
    count: suggestions.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 60, // Estimated row height
    overscan: 5 // Render 5 extra rows
  });
  
  return (
    <div ref={parentRef} className="max-h-80 overflow-auto">
      <div
        style={{
          height: `${rowVirtualizer.getTotalSize()}px`,
          position: 'relative'
        }}
      >
        {rowVirtualizer.getVirtualItems().map((virtualRow) => (
          <div
            key={virtualRow.index}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: `${virtualRow.size}px`,
              transform: `translateY(${virtualRow.start}px)`
            }}
          >
            {renderSuggestionItem(suggestions[virtualRow.index])}
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 13.4 Database Indexing

```sql
-- Optimize mention queries
CREATE INDEX idx_posts_mentions ON posts USING GIN(mentions);
CREATE INDEX idx_posts_user_mentions ON posts(user_id, mentions);
CREATE INDEX idx_comments_mentions ON post_comments USING GIN(mentions);

-- Optimize user search
CREATE INDEX idx_users_name_trigram ON users USING gin(name gin_trgm_ops);
CREATE INDEX idx_users_username_trigram ON users USING gin(username gin_trgm_ops);

-- Full-text search
CREATE INDEX idx_users_search ON users USING gin(
  to_tsvector('english', coalesce(name, '') || ' ' || coalesce(username, ''))
);
```

---

## 14. Testing & Validation

### 14.1 Unit Tests

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import SimpleMentionsInput from '@/components/memory/SimpleMentionsInput';

describe('SimpleMentionsInput', () => {
  it('shows autocomplete when @ is typed', async () => {
    const { container } = render(
      <SimpleMentionsInput value="" onChange={() => {}} />
    );
    
    const editor = container.querySelector('[contenteditable]');
    
    // Type '@'
    fireEvent.input(editor, { target: { textContent: '@' } });
    
    await waitFor(() => {
      expect(screen.getByText('Type to search...')).toBeInTheDocument();
    });
  });
  
  it('searches users as query is typed', async () => {
    mockFetch('/api/users/search?q=maria', {
      data: [{ id: 'user_123', username: 'maria_rodriguez', name: 'Maria' }]
    });
    
    const { container } = render(
      <SimpleMentionsInput value="" onChange={() => {}} />
    );
    
    const editor = container.querySelector('[contenteditable]');
    
    fireEvent.input(editor, { target: { textContent: '@maria' } });
    
    await waitFor(() => {
      expect(screen.getByText('Maria')).toBeInTheDocument();
    });
  });
  
  it('inserts mention when user selected', async () => {
    const onChange = jest.fn();
    const onMentionsChange = jest.fn();
    
    const { container } = render(
      <SimpleMentionsInput 
        value="" 
        onChange={onChange}
        onMentionsChange={onMentionsChange}
      />
    );
    
    // Type and select
    const editor = container.querySelector('[contenteditable]');
    fireEvent.input(editor, { target: { textContent: '@maria' } });
    
    await waitFor(() => screen.getByText('Maria'));
    
    fireEvent.click(screen.getByText('Maria'));
    
    expect(onChange).toHaveBeenCalledWith(
      expect.stringContaining('@user:user_123:maria_rodriguez')
    );
    expect(onMentionsChange).toHaveBeenCalledWith(['user_123']);
  });
});
```

### 14.2 Integration Tests

```typescript
describe('Post Creation with Mentions', () => {
  it('creates post and sends notifications', async () => {
    const { user } = renderWithAuth(<PostCreator />);
    
    // Type content with mention
    const input = screen.getByPlaceholderText(/share your memory/i);
    await userEvent.type(input, 'Dancing with @maria');
    
    // Wait for autocomplete
    await waitFor(() => screen.getByText('Maria Rodriguez'));
    
    // Select mention
    await userEvent.click(screen.getByText('Maria Rodriguez'));
    
    // Submit post
    await userEvent.click(screen.getByTestId('button-share'));
    
    // Verify API calls
    expect(mockFetch).toHaveBeenCalledWith('/api/posts', {
      method: 'POST',
      body: expect.objectContaining({
        mentions: ['user_123']
      })
    });
    
    // Verify notification created
    await waitFor(() => {
      expect(mockSocket.emit).toHaveBeenCalledWith(
        'notification:new',
        expect.objectContaining({
          type: 'mention',
          userId: 123
        })
      );
    });
  });
});
```

### 14.3 E2E Tests (Playwright)

```typescript
test('user can mention another user in post', async ({ page }) => {
  await page.goto('/memories');
  
  // Focus input
  await page.click('[data-testid="mentions-input"]');
  
  // Type mention trigger
  await page.keyboard.type('@maria');
  
  // Wait for dropdown
  await page.waitForSelector('.mentions-dropdown');
  
  // Verify search results
  await expect(page.locator('.mentions-dropdown')).toContainText('Maria Rodriguez');
  
  // Select with keyboard
  await page.keyboard.press('Enter');
  
  // Verify mention badge inserted
  await expect(page.locator('.mention-badge')).toContainText('@maria_rodriguez');
  
  // Submit post
  await page.click('[data-testid="button-share"]');
  
  // Verify success
  await expect(page.locator('.toast')).toContainText('Memory shared');
});
```

---

## 15. Production Deployment

### 15.1 Environment Variables

```bash
# Database
DATABASE_URL="postgresql://..."

# API Keys (if using external search services)
# ALGOLIA_API_KEY="..." # Optional: Advanced search
```

### 15.2 Database Migration

```bash
# Push schema to production
npm run db:push --force

# Verify indexes
psql $DATABASE_URL -c "SELECT * FROM pg_indexes WHERE tablename = 'posts';"
```

### 15.3 Performance Monitoring

**Key Metrics:**
- Autocomplete response time (<300ms)
- Notification delivery time (<100ms)
- Search query performance (<200ms)
- Feed loading with mentions (<500ms)

### 15.4 Pre-Deploy Checklist

- [ ] All environment variables set
- [ ] Database schema up to date with indexes
- [ ] Unit tests passing
- [ ] Integration tests passing
- [ ] E2E tests passing
- [ ] Autocomplete working in all contexts (posts, comments)
- [ ] Notifications sending correctly
- [ ] Feed algorithm includes mention scoring
- [ ] Mobile responsive
- [ ] Keyboard navigation working
- [ ] Dark mode support
- [ ] Socket.io real-time updates working

---

## Appendix A: Complete API Reference

### User Search
- `GET /api/users/search?q={query}` - Search users for mentions

### Event Search
- `GET /api/events/search?q={query}` - Search events for mentions

### Group Search
- `GET /api/groups/search?q={query}` - Search groups for mentions

### City Search
- `GET /api/cities/search?q={query}` - Search cities for mentions

### Posts
- `POST /api/posts` - Create post with mentions
- `GET /api/users/:userId/mentions` - Get posts where user mentioned

### Notifications
- `GET /api/notifications` - Get user notifications
- `PATCH /api/notifications/:id/read` - Mark notification as read

---

## Appendix B: TypeScript Types

```typescript
// Complete type definitions
export type EntityType = 'user' | 'event' | 'group' | 'city';

export type Token = TextToken | MentionToken;

export interface TextToken {
  kind: 'text';
  text: string;
}

export interface MentionToken {
  kind: 'mention';
  type: EntityType;
  id: string;
  name: string;
}

export interface MentionData {
  id: string;
  display: string;
  type: EntityType;
  avatar?: string;
  subtitle?: string;
  metadata?: Record<string, any>;
}

export interface SimpleMentionsInputProps {
  value: string;
  onChange: (content: string) => void;
  onMentionsChange?: (mentionIds: string[]) => void;
  placeholder?: string;
  className?: string;
  disabled?: boolean;
  rows?: number;
}
```

---

## Document End

**Status:** Production-Ready âœ…  
**Last Updated:** January 9, 2025  
**Total Lines:** 3,600+  
**Zero-Knowledge Reconstruction:** Complete
